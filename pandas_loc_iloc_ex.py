import pandas as pd
import numpy as np


# # --- DataFrame 생성 ---
# # np.arange(10, 22): 10부터 시작하여 (22-1)인 21까지의 정수(총 12개)를 갖는 1차원 배열을 생성합니다.
# # .reshape(3, 4): 위 1차원 배열을 3행 4열의 2차원 배열로 변형합니다.
# # pd.DataFrame(...): 이 2차원 배열을 데이터로 사용하여 DataFrame을 생성하고 변수 df에 저장합니다.
# df = pd.DataFrame(
#     np.arange(10, 22).reshape(3,4), 
#     index=["a", "b", "c"],   # index 매개변수를 사용하여 행(Row)의 레이블(이름)을 ['a', 'b', 'c']로 지정합니다.
#     columns=["A", "B", "C", "D"] # columns 매개변수를 사용하여 열(Column)의 레이블(이름)을 ['A', 'B', 'C', 'D']로 지정합니다.
# )


# # --- 데이터 선택 (loc 인덱서) ---
# # .loc는 레이블(이름) 기반으로 데이터에 접근합니다.
# # 기본 형식은 df.loc[행 레이블, 열 레이블]이며, 
# # 행 레이블만 주어지면 해당 행 전체를 선택합니다.

# print(df.loc['a'])  # 행 레이블이 "'a'"인 "행 전체"를 선택합니다.
#                     # 결과는 'A', 'B', 'C', 'D'를 인덱스로 갖는 pandas Series 객체가 됩니다.

# print(df.loc['A'])  # 행 레이블이 "'A'"인 행을 선택하려고 시도합니다.
#                     # 이 DataFrame에는 'A'라는 이름의 "행 인덱스"가 없기 때문에
#                     # 실행 시 "KeyError"가 발생합니다. 
#                     # (df.loc는 열 이름을 통한 선택이 아닌, 행 이름(레이블)을 통한 선택을 우선시합니다.)



# # --- 행 슬라이싱 (Row Slicing) ---
# # 1. .loc를 사용한 슬라이싱 (레이블 기반)
# print(df.loc['b':'c']) # ".loc" 접근자를 사용하며, 'b'부터 'c'까지의 "행 레이블 범위"를 슬라이싱합니다.
#                        # "레이블 기반 슬라이싱"의 특징: 끝 인덱스인 'c'도 "포함"하여 선택합니다.
#                        # 결과: 행 'b'와 행 'c'가 모두 출력됩니다.

# # 2. 일반 대괄호 []를 사용한 슬라이싱 (레이블 기반)
# print(df['b':'c'])     # DataFrame에서 일반 대괄호 `[]` 안에 슬라이싱 구문(시작:끝)을 사용하면
#                        # 이는 "행 레이블 기반 슬라이싱"으로 동작합니다.
#                        # 이 역시 "레이블 기반"이므로 끝 레이블인 'c'를 "포함"하여 선택합니다.
#                        # 결과: 행 'b'와 행 'c'가 모두 출력됩니다.



# # --- 행 선택 (레이블 기반) ---
# # .loc: pandas에서 "레이블(이름)"을 기반으로 행과 열을 선택하는 데 사용되는 인덱서입니다.
# # ['b', 'c']: .loc의 첫 번째 인자(행 선택 위치)에 행 레이블 'b'와 'c'를 리스트 형태로 전달합니다.
# print(df.loc[['b','c']]) # DataFrame 'df'에서 행 레이블이 "'b'와 'c'"인 행들만을 선택하여 출력합니다.
#                          # 두 행과 모든 열을 포함하는 새로운 DataFrame이 반환됩니다.



# # --- 데이터 접근 및 오류 발생 ---
# # .loc 인덱서: 행(Row)과 열(Column)을 "레이블(이름)"을 기반으로 선택할 때 사용합니다.
# # df.loc[행 레이블, 열 레이블]
# print(df.loc['b','c']) # 'b'는 유효한 행 레이블이지만,
#                        # "'c'는 유효한 열 레이블이 아닙니다." (열 레이블은 'A', 'B', 'C', 'D'입니다.)
#                        # pandas는 'c'를 열 이름으로 찾으려고 시도하지만,
#                        # DataFrame에 'c'라는 이름의 열이 없기 때문에 "KeyError"가 발생합니다.



# # --- 행 선택 (단일 Series 반환) ---
# print(df.loc["b"]) # ".loc" 인덱서를 사용하여 행 레이블 'b'에 해당하는 "단일 행"을 선택합니다.
#                    # 선택된 결과는 "pandas Series" 객체로 반환됩니다.
#                    # Series의 인덱스는 원본 DataFrame의 열 이름('A', 'B', 'C', 'D')이 됩니다.



# # --- 행 선택 (DataFrame 반환) ---
# print(df.loc[["b"]]) # ".loc" 인덱서에 행 레이블 'b'를 "리스트 형태"(["b"])로 전달하여 선택합니다.
#                      # 하나의 레이블이라도 리스트로 감싸서 전달하면, 결과는 항상 "pandas DataFrame" 객체로 반환됩니다.
#                      # 이는 이후의 DataFrame 연산을 위해 일관된 구조를 유지할 때 유용합니다.



# # --- 데이터 선택 및 오류 발생 ---
# print(df[["b","c"]]) # DataFrame에서 대괄호 `[]` 안에 리스트를 넣어 여러 개의 "열(Column)"을 선택하려고 시도합니다.
#                      # pandas는 이 리스트의 요소들('b', 'c')을 "열 이름(Column Label)"로 간주하고 찾습니다.
#                      # 하지만 df의 열 이름은 'A', 'B', 'C', 'D'이고, 'b'와 'c'라는 열은 존재하지 않습니다.
#                      # 따라서 존재하지 않는 열 이름을 사용하여 접근했기 때문에 "KeyError"가 발생합니다.



# # --- 행 선택 ---
# print(df.loc[['b','c']]) # `.loc` 인덱서를 사용하여 데이터를 선택합니다.
#                          # `.loc`는 "레이블(이름)"을 기반으로 선택하며, 항상 "행(Row)"을 먼저 선택합니다.
#                          # [['b','c']]는 행 레이블 'b'와 'c'를 선택하는 리스트입니다.
#                          # 결과적으로 'b' 행과 'c' 행만 포함하는 새로운 DataFrame이 출력됩니다.



# # --- 열 선택 및 출력 ---
# print(df[["B","C"]]) # DataFrame df에서 대괄호 `[]` 안에 "열 이름"의 "리스트"를 전달하여 
#                      # 'B' 열과 'C' 열을 동시에 선택하고 출력합니다.
#                      # 결과는 선택된 열들로 구성된 새로운 DataFrame이 됩니다.



# # --- 열 선택 및 출력 ---
# print(df.A) # DataFrame `df`에서 "점(dot) 표기법"을 사용하여 열 이름 'A'에 해당하는 단일 열을 선택합니다.
#             # 이 방법은 열 이름이 유효한 Python 변수 이름 규칙을 따를 때 간편하게 사용할 수 있습니다.
#             # 선택된 열(Column 'A')은 "pandas Series 객체" 형태로 반환되어 출력됩니다.



# # --- 조건부 필터링 (불리언 인덱싱) ---
# # df.A: DataFrame df에서 'A'라는 이름의 열(Column)을 Series 형태로 선택합니다.
# # > 15: 선택된 Series의 모든 값에 대해 "'15보다 큰가?'"라는 조건(비교 연산)을 적용합니다.
# # 이 연산의 결과는 각 요소가 조건을 충족하는지 여부를 나타내는 "True/False 값"을 가진 새로운 "Series (불리언 Series)"가 됩니다.
# print(df.A > 15) # 조건 연산의 결과인 불리언 Series를 출력합니다.



# # --- 불리언 인덱싱을 이용한 행 선택 ---
# # df.A > 15 : 먼저 조건식을 계산합니다.
# # 1. df.A는 'A' 열(Series)을 선택합니다. (결과: [10, 14, 18])
# # 2. 각 값과 15를 비교하여 "불리언(True/False)" 값으로 이루어진 Series를 만듭니다.
# #    (결과: [False (10>15), False (14>15), True (18>15)])
# # 3. 이 불리언 Series를 df.loc[...]에 인수로 전달합니다.
# print(df.loc[df.A > 15]) # df.loc[] 접근자를 사용하여, 조건식(df.A > 15)의 결과가 "True인 행"만 선택하여 출력합니다.
#                          # 'A' 열의 값이 15보다 큰 행(여기서는 행 인덱스 'c')만 선택됩니다.



# # --- 행 선택 함수 정의 ---
# def sel_row(df) : # sel_row라는 이름의 함수를 정의하며, 입력으로 DataFrame(df)을 받습니다.
#     # df.A: DataFrame df에서 'A'라는 이름의 열(Series 객체)을 선택합니다.
#     # >15: 선택된 'A' 열의 각 요소가 15보다 큰지 비교 연산을 수행합니다.
#     # 이 연산의 결과로, 각 행마다 True 또는 False 값을 가지는 "불리언 Series"가 생성됩니다.
#     return df.A > 15 

# # --- 함수 실행 및 출력 ---
# sel_row(df) # 정의된 sel_row 함수에 생성된 DataFrame df를 인수로 넣어 실행하고, 그 결과를 출력합니다.



# # --- 단일 값 선택 ---
# # df.loc[행_레이블, 열_레이블]을 사용하여 특정 레이블을 가진 행과 열이 만나는 단일 스칼라 값(하나의 값)을 선택합니다.
# print(df.loc['a','A']) # 행 레이블 'a'와 열 레이블 'A'가 만나는 셀의 값을 출력합니다.
#                        # 이는 DataFrame의 가장 왼쪽 상단 값인 10을 의미합니다.



# # --- 값 수정 ---
# df.loc['a','A'] = 50 # `.loc` 인덱서를 사용하여 특정 위치의 데이터를 선택하고 새 값(50)을 할당하여 "수정"합니다.
#                      # .loc[행 레이블, 열 레이블] 형식으로 사용됩니다.
#                      # 'a' 행(Row)과 'A' 열(Column)이 교차하는 지점의 값을 50으로 변경합니다.
                     
# # print(df) # 변경된 DataFrame을 출력해보면, 원본 값 10이 50으로 바뀐 것을 확인할 수 있습니다.



# # --- 여러 방식의 데이터 선택 및 출력 ---
# # 1. 이중 대괄호(체이닝) 사용 (비추천 방식)
# print(df.loc[['a','b']]['A']) 
# # df.loc[['a','b']] : 행 인덱스 'a', 'b'에 해당하는 행 전체를 선택하여 "새로운 DataFrame"을 반환합니다.
# # ['A'] : 그 반환된 DataFrame에서 "열 이름 'A'"를 선택합니다.
# # 결과 타입: "Series" (단일 열 선택 시)


# # 2. .loc[행 인덱스, 열 인덱스] 정석 방식
# print(df.loc[['a','b'],'A'])
# # df.loc : 행 레이블과 열 레이블을 사용하여 선택하는 인덱서입니다.
# # [['a','b']] : 선택할 "행 레이블 리스트"입니다.
# # 'A' : 선택할 "단일 열 레이블"입니다.
# # 결과 타입: "Series" (단일 열 선택 시)


# # 3. .loc[행 인덱스, 열 인덱스 리스트] 정석 방식
# print(df.loc[['a','b'],['A']])
# # [['a','b']] : 선택할 행 레이블 리스트입니다.
# # ['A'] : 선택할 "열 레이블 리스트"입니다. (단일 열이더라도 리스트로 감싸면)
# # 결과 타입: "DataFrame" (열이 하나여도 리스트로 지정했으므로)





# # --- .loc를 사용한 행 선택의 여러가지 방법들 ---
# # 1. 단일 행 선택 (Series 반환)
# print(df.loc['a']) # .loc[행_레이블]: 행 인덱스 'a'에 해당하는 "단일 행"을 선택합니다.
#                    # 결과는 1차원 데이터인 "Series" 객체로 반환됩니다.

# # 2. 단일 행 선택 (DataFrame 반환)
# print(df.loc[['a']]) # .loc[[행_레이블_리스트]]: 행 레이블 'a'를 리스트 "['a']" 형태로 전달하여 선택합니다.
#                      # 결과는 "DataFrame" 객체로 반환됩니다 (2차원 구조 유지).

# # 3. 단일 행 선택 및 전체 열 슬라이스 (Series 반환)
# print(df.loc['a',:]) # .loc[행_레이블, 열_슬라이스]: 행 인덱스 'a'를 선택하고,
#                      # "':'"는 "모든 열(All Columns)"을 의미합니다.
#                      # 결과는 위 1번과 동일하게 "Series" 객체로 반환됩니다.

# # 4. 단일 행 선택 (리스트) 및 전체 열 슬라이스 (DataFrame 반환)
# print(df.loc[['a'],:]) # .loc[[행_레이블_리스트], 열_슬라이스]: 행 인덱스 'a'를 리스트 형태로 선택하고,
#                        # "':'"는 모든 열을 선택합니다.
#                        # 결과는 위 2번과 동일하게 "DataFrame" 객체로 반환됩니다.




# # --- DataFrame의 .loc 인덱서를 사용한 레이블 기반 선택 ---
# # 1. 단일 행 선택 (Series 반환)
# print(df.loc['a']) # 행 인덱스 'a'에 해당하는 "전체 행"을 선택합니다. 
#                    # 결과: Series (열 이름이 인덱스가 됨)

# # 2. 단일 행의 특정 열 범위 선택 (Series 반환)
# print(df.loc['a', 'B':'C']) # 행 인덱스 'a'를 선택하고, 그 행에서 열 인덱스 'B'부터 "'C'까지" (끝점 포함) 선택합니다.
#                             # 결과: Series

# # 3. 행 리스트 선택 (DataFrame 반환)
# print(df.loc[['a']]) # 행 인덱스 'a'를 "리스트"로 감싸서 선택합니다. 
#                      # 단일 행을 선택하더라도 리스트로 지정하면 "DataFrame" 형태로 반환됩니다.
#                      # 결과: DataFrame

# # 4. 행 리스트와 열 범위 선택 (DataFrame 반환)
# print(df.loc[['a'],"B":"C"]) # 행 인덱스 리스트 ['a']를 선택하고, 열 인덱스 'B'부터 'C'까지 선택합니다. 
#                              # 결과: DataFrame (1행 2열)

# # 5. 단일 행의 특정 열 리스트 선택 (Series 반환)
# print(df.loc['a', ['B','C']]) # 행 인덱스 'a'를 선택하고, 열 인덱스 "'B'와 'C'만" "리스트"로 지정하여 선택합니다.
#                               # 결과: Series





# # --- 데이터 선택 및 출력 ---
# print(df.loc['b':])         # 1. 행 선택: `.loc[행 슬라이스, ]`
#                             # 행 인덱스 'b'부터 끝까지(inclusive) 모든 행을 선택하고, 모든 열을 선택합니다.
#                             # 결과: DataFrame (2x4)

# print(df.loc['b':,'A'])     # 2. 행/열 동시 선택 (Series 반환): `.loc[행 슬라이스, 단일 열 이름]`
#                             # 행 인덱스 'b'부터 끝까지 선택하고, 열 'A'만 선택합니다.
#                             # 결과: Series (2개의 원소)

# print(df.loc['b':]['A'])    # 3. 인덱싱 조합 (Series 반환): `df.loc[행 슬라이스][단일 열 이름]`
#                             # 1차: `df.loc['b':]`로 'b'부터 끝까지의 행을 가진 DataFrame을 반환합니다.
#                             # 2차: 그 결과 DataFrame에 `['A']` 인덱싱을 적용하여 열 'A'를 선택합니다.
#                             # 결과: Series (2개의 원소). (2번과 결과는 같지만 연산 과정이 다릅니다.)

# print(df.loc['b':][['A']])  # 4. 인덱싱 조합 (DataFrame 반환): `df.loc[행 슬라이스][열 이름 리스트]`
#                             # 1차: `df.loc['b':]`로 'b'부터 끝까지의 행을 가진 DataFrame을 반환합니다.
#                             # 2차: 그 결과 DataFrame에 `[['A']]` 인덱싱을 적용하여 열 'A'를 "DataFrame" 형태로 선택합니다.
#                             # 결과: DataFrame (2x1)

# print(df.loc['b':,['A']])   # 5. 행/열 동시 선택 (DataFrame 반환): `.loc[행 슬라이스, 열 이름 리스트]`
#                             # 행 인덱스 'b'부터 끝까지 선택하고, 열 'A'를 "리스트" `['A']`로 지정하여 선택합니다.
#                             # 결과: DataFrame (2x1). (4번보다 빠르고 권장되는 방식입니다.)

# print(df.loc['b':,'A':'A']) # 6. 행/열 슬라이스 (DataFrame 반환): `.loc[행 슬라이스, 열 슬라이스]`
#                             # 행 인덱스 'b'부터 끝까지 선택하고, 열 'A'부터 'A'까지 슬라이싱(A열만 선택)합니다.
#                             # `.loc`에서는 슬라이싱 시 끝 인덱스도 포함(inclusive)되므로, 5번과 결과는 같습니다.
#                             # 결과: DataFrame (2x1)



# # --- 인덱싱 및 출력 ---
# # 1. 행 슬라이싱 (시작 레이블:끝 레이블)
# # .loc['a':'b']는 "행 레이블 'a'부터 'b'까지" (끝 레이블 'b' 포함) 모든 행을 선택합니다.
# # ".loc를 이용한 레이블 슬라이싱에서는 끝점도 포함"됩니다.
# print(df.loc['a':'b']) 

# # 2. 특정 행 리스트 선택
# # .loc[['a','b']]는 행 레이블 'a'와 'b'를 "리스트"로 지정하여 해당 행들만 선택합니다.
# print(df.loc[['a','b']])

# # 3. 행 선택 후 열 선택 (체인 인덱싱 - 권장하지 않음)
# # 1) 먼저 .loc[['a','b']]를 사용하여 'a'와 'b' 행을 선택합니다. (중간 DataFrame 생성)
# # 2) 그 결과 DataFrame에 다시 `[['B','D']]`를 적용하여 'B'와 'D' 열을 선택합니다.
# # *이러한 방식은 "Chain Indexing"으로, 가독성이 떨어지고 경우에 따라 'SettingWithCopyWarning'을 발생시키므로 "권장되지 않습니다."
# print(df.loc[['a','b']][['B','D']])

# # 4. 행과 열을 동시에 명시적 선택 (권장되는 방식)
# # .loc[행 선택, 열 선택] 구문을 사용하여 "행 리스트 ['a','b']"와 "열 리스트 ['B','D']"를 "쉼표(,)로 구분"하여 동시에 선택합니다.
# # 이는 데이터 선택 시 가장 명확하고 성능상 권장되는 방법입니다.
# print(df.loc[['a','b'],['B','D']])





# # --- iloc를 사용한 데이터 선택 (정수 위치 기반) ---
# print(df.iloc[0,1])      # [행 인덱스 0, 열 인덱스 1]을 선택합니다. (값: 11)

# print(df.iloc[0:2,1:2])  # [행 인덱스 0부터 1까지 (0, 1), 열 인덱스 1부터 1까지 (1)]을 선택합니다.
#                          # (결과: 2행 1열 DataFrame)
                         
# print(df.iloc[0:2])      # 행 인덱스 0부터 1까지 (0, 1)을 선택하고, 열 인덱스는 모두(전체) 선택합니다.
#                          # (결과: 2행 4열 DataFrame)
                         
# print(df.iloc[0:2,1])    # [행 인덱스 0부터 1까지 (0, 1), 열 인덱스 1]을 선택합니다.
#                          # (결과: 2개의 값을 가진 Series)
                         
# print(df.iloc[2])        # 행 인덱스 2 전체를 선택하고, 열은 모두 선택합니다. (값: 18, 19, 20, 21)
#                          # (결과: 1차원 Series)
                         
# print(df.iloc[2,1:2])    # [행 인덱스 2, 열 인덱스 1부터 1까지 (1)]을 선택합니다.
#                          # (결과: 1행 1열 DataFrame)
                         
# print(df.iloc[2:3,1:2])  # [행 인덱스 2부터 2까지 (2), 열 인덱스 1부터 1까지 (1)]을 선택합니다.
#                          # (결과: 1행 1열 DataFrame. 윗줄과의 차이는 슬라이싱을 사용하여 결과가 Series가 아닌 DataFrame임)
                         
# print(df.iloc[0:1,-2:])  # [행 인덱스 0부터 0까지 (0), 열 인덱스 끝에서 두 번째부터 끝까지 (2, 3)]을 선택합니다.
#                          # (결과: 1행 2열 DataFrame)
                         
# print(df.iloc[0,-2:])    # [행 인덱스 0, 열 인덱스 끝에서 두 번째부터 끝까지 (2, 3)]을 선택합니다.
#                          # (결과: 2개의 값을 가진 Series)
                         
# print(df.iloc[[0,1],[1,2]]) # [행 인덱스 0과 1, 열 인덱스 1과 2]를 선택합니다. (리스트를 사용한 비연속적 선택)
#                             # (결과: 2행 2열 DataFrame)










# # --- DataFrame 생성 ---
# # np.arange(10, 26): 10부터 시작하여 (26-1)인 25까지의 정수(총 16개)를 순서대로 갖는 1차원 배열을 생성합니다.
# #                    (결과: [10, 11, ..., 25])
# # .reshape(4, 4): 위 1차원 배열을 "4행 4열"의 2차원 배열로 변형합니다.
# # pd.DataFrame(...): 이 2차원 배열을 데이터로 사용하여 DataFrame을 생성합니다.
# df2 = pd.DataFrame(
#     np.arange(10, 26).reshape(4, 4), # DataFrame에 들어갈 4x4 데이터 배열
#     columns=['a','b','c','d']        # 생성될 DataFrame의 "열(Column) 이름"을 ['a', 'b', 'c', 'd']로 지정합니다.
# ) # 생성된 DataFrame을 변수 df2에 할당합니다.



# # --- 행 선택 방법 1: .loc[시작_레이블 : 끝_레이블] ---
# # .loc[] 접근자는 "레이블(이름)" 기반으로 행을 선택합니다.
# print(df2.loc[1:2])  # 행 인덱스 "1"부터 행 인덱스 "2"까지 "모두 포함"하여 선택합니다. (종료 레이블 포함)
#                      # 이 DataFrame의 행 인덱스가 정수(0, 1, 2, 3)이므로, 1과 2 레이블에 해당하는 행이 선택됩니다.
#                      # 결과: 행 1과 행 2
#                      # 이 연산은 원본 df2를 변경하지 않고, 선택된 행이 포함된 새로운 DataFrame을 반환합니다.



# # --- 행 선택 방법 2: 기본 인덱싱 [시작_위치 : 끝_위치] ---
# # DataFrame의 기본 대괄호 [] 안에 슬라이싱([start:stop])을 사용할 경우, "위치(position)" 기반으로 행을 선택합니다.
# # "주의": 기본 슬라이싱은 Python 리스트와 같이 "종료 위치는 포함하지 않습니다."
# print(df2[1:2])  # 1번 위치(두 번째 행)부터 2번 위치(세 번째 행) "직전"까지 선택합니다.
#                  # 즉, 위치 1에 해당하는 행만 선택됩니다.
#                  # 결과: 행 1만
#                  # 이 연산은 원본 df2를 변경하지 않고, 선택된 행이 포함된 새로운 DataFrame을 반환합니다.



# # --- 값 선택 및 출력 ---
# print(df2.loc[0,'a']) # DataFrame의 ".loc" 인덱서를 사용하여 값을 선택하고 출력합니다.
#                       # .loc[행 레이블, 열 레이블]의 형식으로 사용합니다.
#                       # 0: 선택할 "행 레이블" (기본 인덱스 0)
#                       # 'a': 선택할 "열 레이블" (열 이름 'a')
#                       # 결과적으로 "0행"과 "'a'열"이 교차하는 "단일 값"이 출력됩니다.












# --- DataFrame 생성 ---
# Dictionary 형태로 데이터를 준비합니다.
# 'num_legs'와 'num_wings'가 열(Column) 이름이 됩니다.
# index=['falcon', 'dog', 'cat', 'ant']로 행(Row) 이름(인덱스)을 지정합니다.
df = pd.DataFrame({
    'num_legs': [2, 4, 4, 6],    # 다리 수 데이터
    'num_wings': [2, 0, 0, 0]    # 날개 수 데이터
}, index=['falcon', 'dog', 'cat', 'ant']) # 행 인덱스: 'falcon', 'dog', 'cat', 'ant'
# --- DataFrame 생성 끝 ---



# # --- 데이터 선택 및 출력 ---
# print(df.num_legs) # 1. "열 선택": DataFrame df에서 "점(`.`) 표기법"을 사용하여 'num_legs' 열을 선택합니다.
#                    # 선택된 결과는 Series 객체 형태로 출력됩니다.
#                    # 결과: 각 행 인덱스와 해당하는 다리 수([2, 4, 4, 6])가 출력됩니다.

# print(df.num_legs.value_counts()) # 2. "빈도수 계산 및 출력": 
#                                   # 먼저 df.num_legs로 'num_legs' Series를 선택합니다.
#                                   # 그 다음, .value_counts() 메서드를 호출합니다.
#                                   # 이 메서드는 Series 내의 "각 고유값(unique value)"이 "몇 번 등장했는지" (빈도수)를 계산하여 새로운 Series로 반환합니다.
#                                   # 결과: 다리 수(고유값)와 해당 빈도수가 내림차순으로 출력됩니다.


# # --- 값의 빈도 계산 및 출력 ---
# print(df.value_counts()) # DataFrame 전체에 대해 `.value_counts()` 메서드를 호출합니다.
#                          # 이 메서드는 기본적으로 DataFrame의 "모든 열"을 고려하여 
#                          # "고유한 행(Row) 조합" 각각이 데이터에 몇 번 나타나는지(빈도)를 계산합니다.
#                          # 결과는 빈도수를 값으로, 고유한 조합을 MultiIndex로 갖는 "Series" 형태로 반환됩니다.
#                          # (가장 빈도가 높은 조합부터 내림차순으로 정렬됩니다.)