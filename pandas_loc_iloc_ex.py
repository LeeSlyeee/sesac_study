import pandas as pd
import numpy as np










# 변수 선언 
width = 77
line = "-" * width

# DataFrame 생성
df = pd.DataFrame(np.arange(10,22).reshape(3,4), index=["a","b","c"], columns=['A','B','C','D'])
print(df)

# --- DataFrame 순회 시작: 열(Column) 중심 순회 ---
# 이 방식은 DataFrame이 내부적으로 Series의 딕셔너리처럼 구성되어 있음을 활용합니다.

# 1. 첫 번째 순회: df.items() (열 순회)
for column_name, column_series in df.items(): 
    # df.items()의 역할: DataFrame 'df'를 (열 이름, 해당 열 데이터) 쌍으로 "분리하여 반환"합니다.
    # column_name: 현재 순회 중인 열의 이름입니다. (대부분 Python의 "str" 타입입니다.)
    # column_series: 현재 열 전체의 데이터를 담고 있는 Pandas "Series 객체"입니다. 
    #                 이 Series는 해당 열의 모든 행 값을 보관하며, 행 인덱스(Row Index)를 키로 가집니다.
    # [설명] 이 단계는 "A라는 열을 가져와", "B라는 열을 가져와"라고 DataFrame에게 요청하는 것과 같습니다.
    
    print(type(column_name), column_name)
    # 현재 열 이름의 타입(<class 'str'>)과 실제 열 이름을 출력합니다.
    
    print(f"column_series >> \n{column_series}")
    # 현재 순회 중인 "Series 객체 전체"를 출력합니다. 
    # (예시: A 열 순회 시: index a, b, c와 값 10, 14, 18이 출력됩니다.)
    
    
    # 2. 두 번째 순회: column_series.items() (셀 값 순회)
    for index_key, cell_value in column_series.items(): 
        # column_series.items()의 역할: 위에서 얻은 하나의 열(Series 객체)을 (행 인덱스, 실제 값) 쌍으로 "행 단위로 쪼개서 반환"합니다.
        # index_key: 해당 셀이 속한 행의 인덱스 키입니다. (DataFrame 생성 시 지정된 인덱스 타입, 여기서는 'a', 'b', 'c'와 같은 str 타입입니다.)
        # cell_value: 해당 행 인덱스(index_key)에 위치한 "실제 데이터 값"입니다.
        
        print(index_key, cell_value)
        # 행 인덱스 키와 해당 셀의 값을 출력합니다. (예: 'a 10', 'b 14', 'c 18')
        # [설명] 이 단계는 "A 열에서 인덱스가 'a'인 값은?", "인덱스가 'b'인 값은?"이라고 Series에게 요청하는 것과 같습니다.



print("========================================================================================================================================================================")


# --- DataFrame 데이터 선택(Selection) 및 슬라이싱(Slicing) 시작 ---
# 이 부분은 데이터 접근의 기본적인 방식을 보여줍니다.

print("# df \n", type(df))
print(df)

print("\n# Column 기준으로 처리")
# 단일 대괄호([]) 안에 열 이름을 전달하여 데이터를 선택합니다.

column_series = df["B"] # Series
# 하나의 열 이름("B")을 문자열로 전달했기 때문에, 결과는 "Series" 객체로 반환됩니다.

print('\ndf["B"]\n', type(column_series), '\n', column_series)
# 결과의 타입(<class 'pandas.core.series.Series'>)과 내용을 출력합니다.

column_df = df[["B","C"]] # DataFrame
# 여러 개의 열 이름을 "리스트"([["B","C"]])로 묶어 전달했기 때문에, 결과는 "DataFrame" 객체로 반환됩니다.
# (결과 형태를 DataFrame으로 유지하는 표준적인 방법입니다.)

print('\ndf[["B","C"]]\n', type(column_df), '\n', column_df)
# 결과의 타입(<class 'pandas.core.frame.DataFrame'>)과 내용을 출력합니다.

# #column_df = df["B","C"] # column slicing 처리 불가 (row slicing으로 처리되기 때문)
# 단일 대괄호 내부에 쉼표로 구분된 문자열(튜플)은 Pandas에서 "열 선택"을 위한 표준 구문이 아니며,
# "행 슬라이싱"으로 오인되거나 오류가 발생할 수 있습니다.

print("\n# Row 기준으로 처리 : DataFrame.index 리스트의 index를 기준으로 처리, df[start_index : stop_index-1]")
# 단일 대괄호 안에 "정수 슬라이싱" 구문([1:2])이 사용되면, Pandas는 이를 "행(Row) 기반 슬라이싱"으로 해석합니다.

row_df = df[1:2] 
# 1. 행 인덱스 '1' (레이블 'b'에 해당)부터 시작하여, 끝 인덱스 '2' (포함하지 않음)까지 슬라이싱합니다.
# 2. Python의 표준 규칙에 따라 끝 인덱스는 제외되므로, 결과에는 "행 인덱스 'b'"만 포함됩니다.
# 3. 결과는 "DataFrame" 객체로 반환됩니다.

print('\ndf[1:2]\n', type(row_df), '\n', row_df)
# 결과의 타입(<class 'pandas.core.frame.DataFrame'>)과 내용을 출력합니다.




print("========================================================================================================================================================================")



# --- DataFrame 데이터 선택(Selection) 및 슬라이싱(Slicing) 시작 (Part 2: 심화 슬라이싱) ---
# 이 부분은 명시적/암묵적 행 슬라이싱의 차이를 보여줍니다.

print("# df \n", type(df))
print(df)

print(line)
print("\n# Row 기준으로 slicing 처리")

temp = df[1:3] # DataFrame (DataFrame.index 리스트의 index 기준)
# "암묵적 정수 위치" 슬라이싱입니다. [1]부터 [2]까지 (3은 불포함) 행을 추출합니다. (레이블 'b', 'c' 추출)

print('\ndf[1:3]', type(temp), '\n', temp)

temp = df.iloc[1:3] # DataFrame (DataFrame.index 리스트의 index 기준)
# "명시적 정수 위치 기반 슬라이싱" (.iloc)입니다. [1]부터 [2]까지 (3은 불포함) 행을 추출합니다. 
# "df[1:3]"과 "동일한 결과"를 반환하지만, .iloc는 정수 위치 기반임을 명확히 합니다.

print('\ndf.iloc[1:3]', type(temp), '\n', temp)

temp = df["b":"c"] # DataFrame (DataFrame.index 리스트의 value 기준)
# "암묵적 레이블 기반 슬라이싱"입니다. 슬라이싱에 레이블('b'부터 'c')을 사용하면, Pandas는 이를 "행 기반"으로 해석합니다.
# [주의] 일반적인 Python 슬라이싱과 달리, "끝 레이블('c')도 결과에 포함"됩니다. (레이블 'b', 'c' 추출)

print('\ndf["b":"c"]', type(temp), '\n', temp)

temp = df.loc[['b','c']] # DataFrame (DataFrame.index 리스트의 value 기준)
# "명시적 레이블 기반 선택" (.loc)입니다. 슬라이싱이 아니라 "리스트"를 사용하여 "b"와 "c" 레이블을 가진 행을 명확하게 선택합니다.
# 이는 "df['b':'c']"의 결과와 같지만, .loc를 사용했으므로 "레이블 기반"임을 명확히 합니다.

print('\ndf.loc[["b","c"]]', type(temp), '\n', temp)






print("========================================================================================================================================================================")





# --- DataFrame Column Selection (단일/전체) ---

print("# df \n", type(df))
print(df)

temp = df["B"] # Series
# 1. 단일 열 이름("B")을 전달하여 해당 열을 "Series" 객체로 추출합니다.

print('\n# df["B"]\n', type(temp), '\n', temp)

temp = df["B"][:] # Series
# 1. "df["B"]"로 추출된 "Series 객체"에 대해 다시 전체 슬라이싱([:])을 적용한 형태입니다.
# 2. Series에 전체 슬라이싱을 적용해도 "Series 객체 자체"가 반환됩니다. 이는 "df["B"]"와 "완전히 동일한 결과"를 냅니다.
# 3. 이 구문은 열 "B"의 모든 행 데이터를 추출하겠다는 의도를 강조할 때 사용될 수 있으나, 일반적으로는 불필요합니다.

print('\n# df["B"][:]\n', type(temp), '\n', temp)






print("========================================================================================================================================================================")





# --- Pandas Series 슬라이싱 ---

print("# df \n", type(df))
df

column_series = df["B"][:"b"] # Series의 slicing (column 기준)
# 1. df["B"]: 먼저 DataFrame에서 "B" 열을 추출하여 "Series" 객체를 만듭니다.
# 2. [: "b"]: 추출된 Series에 대해 레이블 기반 슬라이싱을 적용합니다. 
# 3. 레이블 기반 슬라이싱은 시작 레이블부터 "끝 레이블('b')을 포함"하여 데이터를 추출합니다.
#    (즉, 인덱스 'a'와 'b'의 값을 포함합니다.)
# 4. 결과는 원본 Series의 부분 집합인 "Series" 객체입니다.

print('\n# df["B"][:"b"]\n', type(column_series))
# 결과의 타입(<class 'pandas.core.series.Series'>)을 출력합니다.

# Jupyter/IPython 환경에서 변수명을 단독으로 입력하면 내용을 출력합니다.
# print(column_series)와 동일한 기능을 수행합니다.
column_series 

print(line)

series1 = df['B']
# 1. "df['B']"를 실행하여 "B" 열 전체를 새로운 "Series" 객체(series1)로 저장합니다.

print('\n# s1 = df["B"]\n', type(series1), '\n', series1)
# series1의 타입과 내용을 출력합니다.

series2 = series1[:'b']
# 1. "series1" 객체에 대해 "레이블 기반 슬라이싱"을 다시 적용합니다.
# 2. 시작(생략: 첫 번째 인덱스 'a')부터 "끝 레이블 'b'를 포함"하여 슬라이싱합니다.
# 3. 이 과정은 위의 "df["B"][:"b"]"와 "완전히 동일한 결과"를 얻지만, 단계를 나누어 보여줍니다.

print('\n# s2 = s1[:"b"]\n', type(series2), '\n', series2)
# series2의 타입과 내용을 출력합니다.


### 💡 핵심 포인트: Series의 레이블 슬라이싱

# * "레이블 포함 규칙": Pandas에서 "레이블(문자열 인덱스)"을 사용하여 슬라이싱(`start_label:end_label`)할 경우, "`end_label`로 지정된 요소가 결과에 "포함"됩니다". 
#   이는 Python의 정수 위치 슬라이싱(`start_index:end_index`에서 `end_index`가 제외되는 것)과 가장 큰 차이점입니다.
# * "단일 대괄호 역할": `df["B"][:"b"]`에서 바깥쪽 대괄호 `[]`는 "Series의 슬라이싱"을 담당합니다. 
#   앞서 `df["B"]`는 열 선택을 담당했기 때문에, 이는 "열 선택(DataFrame -> Series)" 후 "행 슬라이싱(Series -> 부분 Series)"의 과정입니다.




print("========================================================================================================================================================================")




# --- DataFrame Column Selection (다중 열 선택 및 후속 처리) ---

print("# df \n", type(df))
print(df)

temp = df[["B"]] # DataFrame
# 1. "이중 대괄호"를 사용하여 단일 열("B")을 선택합니다.
# 2. 결과는 "단일 열"이라도 "DataFrame" 객체로 반환됩니다. (df['B']는 Series, df[['B']]는 DataFrame)

print('\n# df[["B"]] \n', type(temp))
# 결과의 타입(<class 'pandas.core.frame.DataFrame'>)을 출력합니다.
print(temp)
# 결과 내용 출력: "B" 열만 포함된 DataFrame입니다.

temp = df[["B","C","D"]] # DataFrame
# 1. "이중 대괄호"를 사용하여 여러 열("B", "C", "D")을 선택합니다.
# 2. 결과는 "DataFrame" 객체로 반환됩니다.

print('\n# df[["B","C","D"]] \n', type(temp))
# 결과의 타입(<class 'pandas.core.frame.DataFrame'>)을 출력합니다.
print(temp)
# 결과 내용 출력: "B", "C", "D" 열만 포함된 DataFrame입니다.

temp = df[["B","C","D"]]["B"] # Series (column)
# 1. 앞부분 `df[["B","C","D"]]`: "B, C, D" 열을 포함하는 "DataFrame"을 생성합니다.
# 2. 뒷부분 `["B"]`: 이 "새로운 DataFrame"에서 다시 "단일 열("B")"을 선택합니다.
# 3. DataFrame에서 단일 열을 선택했으므로, 최종 결과는 "Series" 객체가 됩니다.

print('\n# df[["B","C","D"]]["B"] \n', type(temp))
# 결과의 타입(<class 'pandas.core.series.Series'>)을 출력합니다.
print(temp)
# 결과 내용 출력: "B" 열의 Series 데이터입니다.

temp = df[["B","C","D"]].loc["a"] # Series (row)
# 1. 앞부분 `df[["B","C","D"]]`: "B, C, D" 열을 포함하는 "DataFrame"을 생성합니다.
# 2. 뒷부분 `.loc["a"]`: 이 "새로운 DataFrame"에서 "레이블 기반 접근자 `.loc`"를 사용하여 "a" 레이블을 가진 "행"을 선택합니다.
# 3. 다차원 객체(DataFrame)에서 단일 행/열을 선택했으므로, 최종 결과는 "Series" 객체가 됩니다. (인덱스는 선택된 열 레이블("B", "C", "D")이 됩니다.)

print('\n# df[["B","C","D"]].loc["a"] \n', type(temp))
# 결과의 타입(<class 'pandas.core.series.Series'>)을 출력합니다.
print(temp)
# 결과 내용 출력: 행 "a"의 "B, C, D" 열 값들로 구성된 Series 데이터입니다.

# # temp = df[["B","D"], "a"] # InvalidIndexError
# 1. 이 구문은 유효하지 않습니다. `df[[...], ...]` 형식은 Pandas의 "표준 접근 구문"이 아닙니다.
# 2. "명시적 접근자(.loc 또는 .iloc)" 없이 쉼표를 사용하여 행과 열을 동시에 선택할 수 "없습니다".
# 3. 올바른 구문은 `df.loc["a", ["B", "D"]]`입니다.






print("========================================================================================================================================================================")




# --- 명시적 레이블 기반 접근자 (.loc)를 사용한 행 선택 ---
# .loc는 항상 [행 레이블, 열 레이블] 순서로 데이터를 선택합니다.

print("# df \n", type(df))
print(df)

temp = df.loc["a"] # Series
# 1. `.loc["a"]`: 쉼표(`,`) 뒤의 열 부분이 생략되면, 모든 열을 선택한다는 "암묵적 의미"를 가집니다.
# 2. "행 레이블이 "a"인 행 전체"를 선택합니다.
# 3. DataFrame에서 단일 행을 선택했으므로, 결과는 "Series" 객체로 반환됩니다. (인덱스는 열 이름("A"~"D")이 됩니다.)


print('\n df.loc["a"] \n', type(temp), '\n', temp)
# 결과의 타입(<class 'pandas.core.series.Series'>)과 내용을 출력합니다.

temp = df.loc["a", :] # Series
# 1. `.loc["a", :]`: "행 레이블이 "a"인 행"과 "모든 열(`:`)을 명시적으로" 선택합니다.
# 2. 위의 `df.loc["a"]`와 "완전히 동일한 결과"를 반환하며, 행과 열의 선택을 명확히 보여줍니다.
# 3. 결과는 "Series" 객체로 반환됩니다.

print('\n df.loc["a", :] \n', type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.

temp = df.loc["a", "B":"C"] # Series
# 1. `.loc["a", "B":"C"]`: "행 레이블이 "a"인 행"을 선택하고, 열은 "B"부터 "C"까지 "레이블 슬라이싱"을 적용합니다.
# 2. 레이블 슬라이싱 규칙에 따라 "끝 레이블("C")도 포함"하여 선택합니다.
# 3. 단일 행이 선택되었으므로, 결과는 "Series" 객체로 반환됩니다. (인덱스는 선택된 열 레이블("B", "C")이 됩니다.)

print('\n df.loc["a", "B":"C"] \n', type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.

temp = df.loc["a", ["B","C"]] # Series
# 1. `.loc["a", ["B","C"]]`: "행 레이블이 "a"인 행"을 선택하고, 열은 "리스트"를 사용하여 "B"와 "C"를 "선택"합니다.
# 2. 위의 `df.loc["a", "B":"C"]`와 "동일한 데이터"를 반환하지만, 슬라이싱이 아닌 명시적 리스트 선택 방식을 사용했습니다.
# 3. 결과는 "Series" 객체로 반환됩니다.

print('\n df.loc["a", ["B","C"]] \n', type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.







print("========================================================================================================================================================================")





# --- 명시적 .loc/.iloc를 사용한 DataFrame 형태 유지 선택 ---
# 이 섹션의 모든 선택은 결과가 단일 행이더라도 "DataFrame" 형태로 반환됩니다.

print("# df \n", type(df))
print(df)

temp = df.loc[['a']] # DataFrame
# 1. `.loc[['a']]`: 행 레이블을 "리스트"(`['a']`)로 전달하여 선택합니다.
# 2. 결과가 "리스트" 형태의 선택이면, 선택된 요소가 단 하나이더라도 "DataFrame" 객체로 반환됩니다.
# 3. 이는 행 'a'를 포함하는 단일 행 DataFrame을 반환합니다.

print("\n df.loc[['a']] \n", type(temp), '\n', temp)
# 결과의 타입(<class 'pandas.core.frame.DataFrame'>)과 내용을 출력합니다.

temp = df.loc[['a'], :] # DataFrame
# 1. `.loc[['a'], :]`: 행 레이블을 "리스트"(`['a']`)로 전달하고, 열은 "모두(`:`) 명시적"으로 선택합니다.
# 2. 위의 `df.loc[['a']]`와 "완전히 동일한 결과"를 반환하며, 행 선택을 리스트로 했기 때문에 "DataFrame" 형태를 유지합니다.

print("\n df.loc[['a'], :] \n", type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.

temp = df.loc['a':'a'] # DataFrame
# 1. `.loc['a':'a']`: 행 레이블을 "슬라이싱(`'a':'a'`)으로 전달"하여 선택합니다.
# 2. Pandas 레이블 슬라이싱은 "끝 레이블을 포함"하기 때문에, 'a'부터 'a'까지는 행 'a' 하나를 선택합니다.
# 3. 슬라이싱은 항상 "DataFrame"을 반환하는 특징이 있습니다.

print("\n df.loc['a':'a'] \n", type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.

temp = df.iloc[0:1] # DataFrame
# 1. `.iloc[0:1]`: "정수 위치 기반 슬라이싱"을 사용합니다.
# 2. 위치 "0" (레이블 'a')은 포함하고, 위치 "1"은 "제외"합니다. (Python 표준 슬라이싱 규칙)
# 3. 이 역시 슬라이싱이므로 결과는 "DataFrame" 객체로 반환됩니다.

print("\n df.iloc[0:1] \n", type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.






print("========================================================================================================================================================================")





# --- 명시적 .loc를 사용한 다중 선택 (DataFrame 형태 유지) ---
# .loc는 항상 [행 레이블, 열 레이블] 순서로 데이터를 선택합니다.

print("# df \n", type(df))
print(df)

temp = df.loc[['a'], 'B':'C'] # DataFrame
# 1. `.loc[['a'], 'B':'C']`: 행 선택을 "리스트(`['a']`)"로 지정하여 "차원을 유지"하고, 열은 "B"부터 "C"까지 "슬라이싱"합니다.
# 2. 결과는 행 'a'와 열 'B', 'C'를 포함하는 "DataFrame" 객체로 반환됩니다.
# 3. [참고]: 행을 리스트로 지정하면, 선택된 행이 하나라도 결과 타입이 "DataFrame"이 됩니다.

print("\n df.loc[['a'], 'B':'C'] \n", type(temp), '\n', temp)
# 결과의 타입(<class 'pandas.core.frame.DataFrame'>)과 내용을 출력합니다.

temp = df.loc[['a'], ['B','C']] # DataFrame
# 1. `.loc[['a'], ['B','C']]`: 행과 열 선택 모두 "리스트"(`['a']`, `['B','C']`)를 사용합니다.
# 2. 결과는 행 'a'와 열 'B', 'C'를 포함하는 "DataFrame" 객체로 반환됩니다.
# 3. 이는 "슬라이싱"이 아닌 "명시적인 리스트 기반 선택"이며, "df.loc[['a'], 'B':'C']"와 "동일한 데이터"를 반환합니다.

print("\n df.loc[['a'], ['B','C']] \n", type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.

temp = df.loc[['a','c']] # DataFrame
# 1. `.loc[['a','c']]`: 쉼표(`,`) 뒤의 열 부분이 생략되었으므로 모든 열을 선택합니다.
# 2. 행 레이블을 "리스트(`['a','c']`)"로 전달하여 행 'a'와 'c'를 "모두" 선택합니다.
# 3. 결과는 'a'와 'c' 두 행을 포함하는 "DataFrame" 객체로 반환됩니다.

print("\n df.loc[['a','c']] \n", type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.







print("========================================================================================================================================================================")






# --- Series 체인 인덱싱을 이용한 단일 셀 접근 ---

# print(type(df['A']['a']), df['A']['a']) # df['A','a'] : Error
# 1. `df['A']`: 먼저 DataFrame 'df'에서 열 레이블 'A'를 사용하여 해당 열 전체를 "Series 객체"로 추출합니다.
# 2. `['a']`: 추출된 "Series 객체"에 대해 다시 행 레이블 'a'를 사용하여 해당 위치의 "단일 값"을 추출합니다.
# 3. 이 방식은 "열 선택 후 행 선택"의 순서로 단일 셀에 접근하며, 최종 결과는 "NumPy 데이터 타입(여기서는 <class 'numpy.int64'>)"입니다.

print(type(df['A']['a']), df['A']['a']) 
# 최종 추출된 값의 타입(<class 'numpy.int64'>)과 실제 값(10)을 출력합니다.

# # df['A','a'] : Error
# 1. 주석 처리된 이 구문은 유효하지 않습니다. 단일 대괄호 안에 쉼표(`,`)를 사용하면 Pandas는 이를 "튜플"로 인식하며,
#    "행/열을 동시에 선택하는 표준 방식"이 아니므로 오류(`KeyError` 또는 `InvalidIndexError`)가 발생합니다.
# 2. 행과 열을 동시에 접근하는 "올바른 방식"은 "df.loc['a', 'A']" 또는 "df.iloc[0, 0]"와 같은 "명시적 접근자"를 사용하는 것입니다.





print("========================================================================================================================================================================")





# --- 명시적 접근자 (.loc / .iloc)를 이용한 셀 접근 ---
# 

print(df.loc['a',"A"], df.loc['a']["A"])
# 1. `df.loc['a',"A"]`: "loc"를 사용하여 [행 레이블, 열 레이블] 형태로 "행 'a'"와 "열 'A'"가 만나는 "단일 셀 값(10)"을 추출합니다. 이 방식이 "가장 권장되는 셀 접근 방법"입니다.
# 2. `df.loc['a']["A"]`: `df.loc['a']`로 "행 'a' 전체를 Series로 추출"한 후, 다시 `["A"]`로 "열 레이블 'A'"를 인덱싱하여 "단일 셀 값(10)"을 추출합니다. (체인 인덱싱 방식)

print(df.iloc[0,0])
# 1. `df.iloc[0,0]`: "iloc"를 사용하여 [행 위치, 열 위치] 형태로 "행 0번째"와 "열 0번째"가 만나는 "단일 셀 값(10)"을 추출합니다.
# 2. 이는 "정수 위치"를 사용하여 셀에 접근하는 "가장 권장되는 방법"입니다.

print(df.iloc[0][0])
# 1. `df.iloc[0]`: 먼저 "행 0번째(레이블 'a')" 전체를 "Series"로 추출합니다.
# 2. `[0]`: 추출된 Series 객체에 대해 다시 "정수 위치 0"으로 인덱싱하여 "단일 셀 값(10)"을 추출합니다. (체인 인덱싱 방식)
# 3. 이 방식은 값 할당 시 "SettingWithCopyWarning"을 유발할 수 있어 일반적으로 "권장되지 않습니다".
# FutureWarning: Series.__getitem__ treating keys as positions is deprecated. 
# In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). 
# To access a value by position, use `ser.iloc[pos]`




print("========================================================================================================================================================================")




# --- .loc를 사용한 다중 행/단일 열 추출 (Chain Indexing 결과 형태) ---

print("# df \n", type(df))
print(df)

temp = df.loc[['a','b']]['A'] # Series
# 1. `df.loc[['a','b']]`: 행 "a"와 "b"를 포함하는 "DataFrame"을 추출합니다.
# 2. `['A']`: 이 DataFrame에서 다시 "A" 열을 선택하여 "Series" 객체를 반환합니다. (Chain Indexing)

print("\n df.loc[['a','b']]['A'] \n", type(temp), '\n', temp)
# 결과의 타입(<class 'pandas.core.series.Series'>)과 내용을 출력합니다.

temp = df.loc[['a','b'],'A'] # Series
# 1. `df.loc[['a','b'],'A']`: "행 리스트(`['a','b']`)"와 "단일 열 레이블(`'A'`)"을 쉼표로 구분하여 "한 번에" 선택합니다.
# 2. 행은 여러 개이지만 열이 하나이므로, 결과는 "Series" 객체로 반환됩니다. (이것이 "Chain Indexing보다 권장"되는 방식입니다.)

print("\n df.loc[['a','b'],'A'] \n", type(temp), '\n', temp)
# 결과의 타입(<class 'pandas.core.series.Series'>)과 내용을 출력합니다.

temp = df.loc[['a','b'],['A']] # DataFrame
# 1. `df.loc[['a','b'],['A']]`: 행과 열 선택 모두 "리스트"(`['a','b']`, `['A']`)를 사용합니다.
# 2. "선택된 열이 하나라도" 리스트로 지정되었기 때문에, 결과는 "DataFrame" 객체로 반환됩니다. (차원 유지)

print("\n df.loc[['a','b'],['A']] \n", type(temp), '\n', temp)
# 결과의 타입(<class 'pandas.core.frame.DataFrame'>)과 내용을 출력합니다.




print("========================================================================================================================================================================")





# --- .loc를 사용한 단일 행 선택 시 Series vs DataFrame ---

print("# df \n", type(df))
print(df)

temp = df.loc['a'] # Series
# 1. `.loc['a']`: 행을 "단일 레이블"로 선택하면, 결과는 "Series"가 됩니다. (차원 감소)

print("\n df.loc['a'] \n", type(temp), '\n', temp)
# 결과의 타입(<class 'pandas.core.series.Series'>)과 내용을 출력합니다.

temp = df.loc[['a']] # DataFrame
# 1. `.loc[['a']]`: 행을 "리스트"로 선택하면, 결과는 "DataFrame"이 됩니다. (차원 유지)

print("\n df.loc[['a']] \n", type(temp), '\n', temp)
# 결과의 타입(<class 'pandas.core.frame.DataFrame'>)과 내용을 출력합니다.

temp = df.loc['a', :] # Series
# 1. `.loc['a', :]`: 행을 "단일 레이블"로, 열을 "전체 슬라이스"로 선택합니다.
# 2. 단일 레이블 선택이 우선하므로, 결과는 "Series"입니다.

print("\n df.loc['a', :] \n", type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.

temp = df.loc[['a'], :] # DataFrame
# 1. `.loc[['a'], :]`: 행을 "리스트"로, 열을 "전체 슬라이스"로 선택합니다.
# 2. 리스트 선택이 우선하므로, 결과는 "DataFrame"입니다.

print("\n df.loc[['a'], :] \n", type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.




print("========================================================================================================================================================================")




# --- .loc를 사용한 슬라이싱 및 체인 인덱싱 ---

print("# df \n", type(df))
print(df)

temp = df.loc['b':] # DataFrame
# 1. `df.loc['b':]`: 행 레이블 "b"부터 "끝까지" 슬라이싱합니다. 슬라이싱은 항상 "DataFrame"을 반환합니다.
# 2. 레이블 슬라이싱 규칙에 따라 "끝 레이블('c')도 포함"합니다.

print("\n df.loc['b':] \n", type(temp), '\n', temp)

temp = df.loc['b':,'A'] # Series
# 1. `df.loc[행 슬라이싱, 단일 열 레이블]`: 열이 "단일 레이블"이므로, 결과는 "Series"입니다.

print("\n df.loc['b':,'A'] \n", type(temp), '\n', temp)

temp = df.loc['b':]['A'] # Series
# 1. `df.loc['b':]`: 먼저 행 슬라이싱 결과인 "DataFrame"을 얻습니다.
# 2. `['A']`: 이 DataFrame에서 단일 열 "A"를 선택하여 "Series"를 반환합니다. (체인 인덱싱)

print("\n df.loc['b':]['A'] \n", type(temp), '\n', temp)

temp = df.loc['b':][['A']] # DataFrame
# 1. `df.loc['b':]`: 행 슬라이싱 결과인 "DataFrame"을 얻습니다.
# 2. `[['A']]`: 이 DataFrame에서 "이중 대괄호"를 사용해 단일 열 "A"를 선택하여 "DataFrame"을 반환합니다. (차원 유지)

print("\n df.loc['b':][['A']] \n", type(temp), '\n', temp)

temp = df.loc['b':,['A']] # DataFrame
# 1. `df.loc[행 슬라이싱, 열 리스트]`: 열을 "리스트(`['A']`)"로 선택했으므로, 결과는 "DataFrame"입니다. (가장 명확한 단일 열 선택 방법 중 하나)

print("\n df.loc['b':,['A']] \n", type(temp), '\n', temp)

temp = df.loc['b':,'A':'A'] # DataFrame
# 1. `df.loc[행 슬라이싱, 열 슬라이싱]`: 열을 "A"부터 "A"까지 슬라이싱합니다. 슬라이싱은 항상 "DataFrame"을 반환합니다.

print("\n df.loc['b':,'A':'A'] \n", type(temp), '\n', temp)

temp = df.loc['b':]['b':'b'] # DataFrame ???????
# 1. `df.loc['b':]`: 행 "b"와 "c"를 포함하는 "DataFrame"을 추출합니다.
# 2. `['b':'b']`: 이 새로운 DataFrame에 대해 다시 "레이블 슬라이싱"을 적용합니다. 이는 행 레이블 "b"부터 "b"까지 (즉, 행 "b" 하나)를 선택합니다.
# 3. 레이블 슬라이싱은 "DataFrame"을 반환합니다. 따라서 "DataFrame"이 맞습니다.

print("\n df.loc['b':]['b':'b'] \n", type(temp), '\n', temp)





print("========================================================================================================================================================================")





# --- 레이블 기반 슬라이싱 및 명시적 .loc 접근 ---

print("# df \n", type(df))
print(df)

temp = df['a':'b'] # DataFrame
# 1. "암묵적 레이블 슬라이싱"입니다. 단일 대괄호에 레이블을 사용하면 "행 기반"으로 해석됩니다.
# 2. 시작 레이블('a')부터 끝 레이블('b')까지 "모두 포함"하여 선택합니다.
# 3. 결과는 항상 "DataFrame" 객체로 반환됩니다.

print("\n df['a':'b'] \n", type(temp), '\n', temp)
# 결과의 타입(<class 'pandas.core.frame.DataFrame'>)과 내용을 출력합니다.

temp = df.loc['a':'b'] # DataFrame
# 1. "명시적 레이블 슬라이싱"(`.loc`)입니다. 행 선택 부분에 'a':'b' 슬라이싱을 적용하고, 열은 생략하여 모두 선택합니다.
# 2. 위의 `df['a':'b']`와 "완전히 동일한 결과"를 반환하며, `.loc`를 사용하여 "레이블 기반"임을 명확히 합니다.

print("\n df.loc['a':'b'] \n", type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.

temp = df.loc[['a','b']] # DataFrame
# 1. `.loc[['a','b']]`: 행 선택 부분에 "리스트"(`['a','b']`)를 사용하여 레이블 'a'와 'b'를 "명시적으로 선택"합니다.
# 2. 슬라이싱이 아닌 리스트를 사용했으므로 "DataFrame" 객체로 반환됩니다.
# 3. 이 역시 위의 슬라이싱 결과와 "동일한 데이터"를 반환합니다.

print("\n df.loc[['a','b']] \n", type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.

temp = df.loc[['a','b']][['B','D']] # DataFrame
# 1. 앞부분 `df.loc[['a','b']]`: 행 'a'와 'b'를 포함하는 "DataFrame"을 생성합니다.
# 2. 뒷부분 `[['B','D']]`: 이 새로운 DataFrame에 대해 다시 "이중 대괄호"로 열 'B'와 'D'를 선택합니다.
# 3. 이는 "체인 인덱싱(Chained Indexing)"의 한 형태로, "DataFrame"을 반환합니다. (값 할당 시 주의 필요)

print("\n df.loc[['a','b']][['B','D']] \n", type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.

temp = df.loc[['a','b'],['B','D']] # DataFrame
# 1. `.loc[['a','b'], ['B','D']]`: 행 선택은 "리스트(`['a','b']`)"로, 열 선택도 "리스트(`['B','D']`)"로 "동시에 명시적"으로 지정합니다.
# 2. "쉼표(`,`)"를 사용하여 행과 열을 분리함으로써, Pandas에서 권장하는 "가장 안전하고 명확한" 다중 행/열 선택 방법을 사용합니다.
# 3. 결과는 행 'a', 'b'와 열 'B', 'D'를 포함하는 "DataFrame" 객체로 반환됩니다.

print("\n df.loc[['a','b'],['B','D']] \n", type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.





print("========================================================================================================================================================================")




# --- 단일 행 추출 (슬라이싱을 통한 DataFrame 형태 유지) ---


print("# df \n", type(df))
print(df)

temp = df[1:2]
# 1. "암묵적 정수 위치 슬라이싱"입니다. 단일 대괄호에 정수를 사용하면 "행 기반"으로 해석됩니다.
# 2. "위치 1" (레이블 'b')부터 "위치 2" ("포함하지 않음")까지 슬라이싱합니다. (Python 표준)
# 3. 결과는 행 'b'만을 포함하는 "DataFrame"입니다.

print("\n df[1:2] \n", type(temp), '\n', temp)
# 결과의 타입(<class 'pandas.core.frame.DataFrame'>)과 내용을 출력합니다.

temp = df.iloc[1:2]
# 1. "명시적 정수 위치 기반 슬라이싱"(`.iloc`)입니다.
# 2. "위치 1"부터 "위치 2" ("포함하지 않음")까지 슬라이싱합니다.
# 3. 위의 `df[1:2]`와 "완전히 동일한 결과"를 반환하며, `.iloc`를 사용하여 "정수 위치 기반"임을 명확히 합니다.

print("\n df.iloc[1:2] \n", type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.

temp = df['b':'b']
# 1. "암묵적 레이블 슬라이싱"입니다. 단일 대괄호에 레이블을 사용하면 "행 기반"으로 해석됩니다.
# 2. 시작 레이블('b')부터 끝 레이블('b')까지 "모두 포함"하여 선택합니다. (Pandas 레이블 슬라이싱 규칙)
# 3. 결과는 행 'b'만을 포함하는 "DataFrame"입니다.

print("\n df['b':'b'] \n", type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.

temp = df.loc['b':'b']
# 1. "명시적 레이블 슬라이싱"(`.loc`)입니다.
# 2. 시작 레이블('b')부터 끝 레이블('b')까지 "모두 포함"하여 선택합니다.
# 3. 위의 `df['b':'b']`와 "완전히 동일한 결과"를 반환하며, `.loc`를 사용하여 "레이블 기반"임을 명확히 합니다.

print("\n df.loc['b':'b'] \n", type(temp), '\n', temp)
# 결과의 타입과 내용을 출력합니다.




print("========================================================================================================================================================================")




## .iloc를 사용한 단일 셀 및 다중 셀 선택

print("# df \n", type(df))
print(df)

temp = df.iloc[0,1]
# 1. `.iloc[행 위치, 열 위치]`: "명시적 정수 위치 기반"으로 단일 셀을 선택합니다.
# 2. "행 0" (레이블 'a')과 "열 1" (레이블 'B')이 만나는 셀의 값 (11)을 추출합니다.
# 3. 단일 셀 값 추출 시 결과는 "스칼라 값 (정수)"으로 반환됩니다.

print("\n df.iloc[0,1] \n", type(temp), '\n', temp)

temp = df.iloc[0:2,1:3] # 행 위치 0, 1 / 열 위치 1, 2 선택 (3은 제외)
# 1. `.iloc[행 슬라이싱, 열 슬라이싱]`: 쉼표를 사용하여 "행과 열을 동시에" 선택합니다.
# 2. 행은 위치 0부터 2 "제외" (행 'a', 'b')를 선택합니다.
# 3. 열은 위치 1부터 3 "제외" (열 'B', 'C')를 선택합니다.
# 4. 결과는 항상 "DataFrame" 객체로 반환됩니다.

print("\n df.iloc[0:2,1:3] \n", type(temp), '\n', temp)


temp = df.iloc[0:2][1:2] # Chained Indexing (체인 인덱싱)
# 1. 앞부분 `df.iloc[0:2]`: 먼저 "행 0과 1" (a, b)만 포함하는 "DataFrame"을 생성합니다.
# 2. 뒷부분 `[1:2]`: 새로 생성된 DataFrame에 대해 다시 "암묵적 정수 위치 슬라이싱"을 적용합니다.
# 3. 이 새로운 DataFrame의 "위치 1" (원래 DataFrame의 'b' 행)만 포함하고, 위치 2는 "제외"합니다.
# 4. 이 방식은 ""체인 인덱싱""이며, 가독성이 낮고 값 할당 시 "SettingWithCopyWarning"을 유발할 수 있어 "권장되지 않습니다".

print("\n df.iloc[0:2][1:2] \n", type(temp), '\n', temp)






print("========================================================================================================================================================================")




## 정수 레이블 DataFrame 생성 및 슬라이싱 비교

df1 = pd.DataFrame(
    np.arange(10, 22).reshape(3, 4), 
    index=[1, 3, 2], # 정수형 레이블을 사용하며, 레이블 순서가 정렬되어 있지 않습니다.
    columns=['A', 'B', 'C', 'D']
)
# DataFrame 'df1' 생성: 행 레이블로 정수 [1, 3, 2]를 사용합니다.

print(type(df1.index), df1.index)
# df1의 인덱스 타입(<class 'pandas.core.indexes.numeric.Int64Index'>)과 실제 레이블(1, 3, 2)을 출력합니다.
print(type(df1), "df1")
print(df1)
# df1의 내용을 출력합니다.

temp = df1[1:2] # DataFrame.index 리스트의 index 사용 (암묵적 정수 위치)
# 1. "암묵적 정수 슬라이싱"입니다. "정수형 레이블이 있을 때" 단일 대괄호와 정수 슬라이싱을 사용하면, Pandas는 이를 "정수 위치 기반"으로 해석합니다.
# 2. "위치 1" (레이블 3에 해당)은 포함하고, "위치 2"는 "제외"합니다. (Python 표준 슬라이싱 규칙)
# 3. 결과는 "두 번째 행(레이블 3)"만 포함하는 DataFrame입니다.
# 4. [주의]: 만약 레이블이 정렬된 정수(예: 0, 1, 2)였다면, Pandas는 이것을 "레이블 기반"으로 해석할지 "위치 기반"으로 해석할지 모호해지므로, "항상 명시적인 `.iloc` 또는 `.loc`를 사용하는 것이 좋습니다".

print("\n df1[1:2] \n", type(temp), '\n', temp)

temp = df1.iloc[1:2] # DataFrame.index 리스트의 index 사용 (명시적 정수 위치)
# 1. "명시적 정수 위치 기반 슬라이싱"(`.iloc`)입니다. 항상 "0부터 시작하는 내부 위치"를 기준으로 합니다.
# 2. "위치 1" (레이블 3에 해당)은 포함하고, "위치 2"는 "제외"합니다.
# 3. `df1[1:2]`와 "완전히 동일한 결과"를 반환하며, "정수 위치 기반"임을 명확히 합니다.

print("\n df1.iloc[1:2] \n", type(temp), '\n', temp)

temp = df1.loc[1:2] # 생성시 주어진 index를 기준으로 처리 (명시적 레이블 기반)
# 1. "명시적 레이블 기반 슬라이싱"(`.loc`)입니다. DataFrame의 "실제 레이블 값"을 기준으로 합니다.
# 2. "레이블 1"부터 "레이블 2"까지 "모두 포함"하여 선택합니다. (Pandas 레이블 슬라이싱 규칙)
# 3. `df1`의 레이블 순서는 "1, 3, 2" 이므로, "레이블 1"과 "레이블 2"를 포함하는 행들이 선택됩니다. (레이블 3은 제외됨)

print("\n df1.loc[1:2] \n", type(temp), '\n', temp)

print(type(df1.index), '\n', df1.index)
# df1의 인덱스 정보를 다시 출력하여 레이블 값을 확인합니다.


### 🔑 정수 인덱스 DataFrame의 핵심 주의사항

# | 구문 | 접근 방식 | 참조 대상 | 끝점 포함 규칙 | 결과 행 |
# | :--- | :--- | :--- | :--- | :--- |
# | `df1[1:2]` | "암묵적 정수 위치" | 0부터 시작하는 "위치" | 끝점 "제외" | 행 위치 1 (`label 3`) |
# | `df1.iloc[1:2]` | "명시적 위치" | 0부터 시작하는 "위치" | 끝점 "제외" | 행 위치 1 (`label 3`) |
# | `df1.loc[1:2]` | "명시적 레이블" | DataFrame의 "레이블 값" | 끝 레이블 "포함" | 레이블 1, 2 |

# "결론": DataFrame의 레이블이 정수일 때, `df[1:2]`와 `df.loc[1:2]`는 "전혀 다른 결과"를 반환할 수 있으므로, 항상 "`.loc` (레이블)" 또는 "`.iloc` (위치)"를 사용하여 의도를 명확히 해야 합니다.





print("========================================================================================================================================================================")




df2 = pd.DataFrame(np.arange(10,22).reshape(3,4), columns=['A','B','C','D'])
# df2 생성: 행 레이블은 기본 정수 인덱스 [0, 1, 2]입니다.

print(type(df2.index), df2.index)
# df2의 인덱스 타입 (<class 'pandas.core.indexes.range.RangeIndex'>)과 레이블 [0, 1, 2]를 출력합니다.

print(type(df2), "df2")
print(df2)
# df2 출력: 
#    A   B   C   D
# 0 10  11  12  13  (위치 0)
# 1 14  15  16  17  (위치 1)
# 2 18  19  20  21  (위치 2)

temp = df2[1:2]
# 1. "암묵적 정수 위치 슬라이싱"입니다. 위치 1은 포함하고 위치 2는 "제외"합니다. (행 레이블 1 추출)

print("\n# df2[1:2] : ", type(temp), '\n', temp)

temp = df2.iloc[1:2]
# 1. "명시적 정수 위치 기반"(`.iloc`) 슬라이싱입니다. 위치 1은 포함하고 위치 2는 "제외"합니다.

print("\n# df2.iloc[1:2] : ", type(temp), '\n', temp)

temp = df2.loc[1:2]
# 1. "명시적 레이블 기반"(`.loc`) 슬라이싱입니다. "레이블 1부터 레이블 2까지 모두 포함"하여 선택합니다.
# 2. df2는 레이블과 위치가 일치하므로, 행 레이블 1과 2가 모두 추출됩니다.

print("\n# df2.loc[1:2] : ", type(temp), '\n', temp)




# 💡 핵심 요약: 정수 인덱스 접근 시 주의사항
# 암묵적 슬라이싱 (df[...]):

# 대괄호 안에 정수 슬라이싱을 넣으면, 인덱스 레이블에 관계없이 항상 내부 정수 위치를 기준으로 작동합니다. (df1[1:2]는 위치 1을 추출)

# .iloc (정수 위치 기반):

# 항상 내부 정수 위치를 기준으로 작동하며, 끝 인덱스는 제외됩니다. (Python 표준 규칙)

# .loc (레이블 기반):

# 항상 실제 레이블 값을 기준으로 작동하며, 정수 레이블이 사용되어도 끝 레이블은 포함됩니다. (df2.loc[1:2]는 레이블 1과 2를 모두 추출)

# df1.loc[1:2]처럼 레이블이 비순차적일 경우, 레이블 순서대로 선택이 이루어집니다.

# 이러한 차이점 때문에, 정수 인덱스를 가진 DataFrame을 다룰 때는 혼동을 피하기 위해 ".iloc"를 사용하여 위치 기반으로 접근하거나 ".loc"를 사용하여 레이블 기반으로 접근하는 것을 명시적으로 구분하는 것이 가장 좋습니다.






print("========================================================================================================================================================================")





## 불리언 인덱싱 (Boolean Indexing)을 사용한 행 필터링

print("# df \n", type(df))
print(df)

temp = df[df["B"] > 11]
# 1. "df["B"] > 11": "B" 열의 값이 11보다 큰지 확인하는 조건식을 수행합니다.
# 2. 이 조건식의 결과는 "Series" 객체이며, 각 행 인덱스에 대해 True 또는 False 값을 가지는 "불리언 마스크(Boolean Mask)"가 됩니다. (True인 행만 선택됨)
#    - 'a': 11 > 11 (False)
#    - 'b': 15 > 11 (True)
#    - 'c': 19 > 11 (True)
# 3. 바깥쪽 대괄호 `df[...]`에 이 불리언 마스크를 전달하면, True에 해당하는 행만 필터링되어 새로운 "DataFrame" 객체로 반환됩니다.

print("\n df[df['B'] > 11] \n", type(temp), '\n', temp)
# 결과의 타입(<class 'pandas.core.frame.DataFrame'>)과 필터링된 내용을 출력합니다. (행 'b'와 'c'만 남음)

# --- 불리언 인덱싱 단계 분리 ---

s = df["B"] > 11
# 1. "B" 열에 대한 조건 검사 결과를 Series 객체 's'에 저장합니다. 이것이 "불리언 마스크"입니다.

print("\n step1. s = df['B'] > 11 \n", type(s), '\n', s)
# s 출력: Series 인덱스 'a': False, 'b': True, 'c': True

temp = df[s]
# 1. 생성된 불리언 마스크 's'를 DataFrame `df[...]`에 직접 전달합니다.
# 2. 마스크의 True 값에 해당하는 행들만 선택되어 "DataFrame" 객체로 반환됩니다.

print("\n step2. df[s] \n", type(temp), '\n', temp)
# 결과는 위의 `df[df["B"] > 11]`와 "완전히 동일"합니다.




# 💡 핵심 요약: 불리언 인덱싱
# 불리언 마스크: 조건식 (df["B"] > 11)의 결과는 DataFrame의 인덱스와 길이가 같은 True / False 값을 가진 "Series 객체(마스크)"입니다.

# 필터링: 이 마스크를 DataFrame의 대괄호(df[...]) 안에 넣으면, True 값에 해당하는 행 전체가 추출되어 새로운 DataFrame이 생성됩니다.

# 다중 조건: 여러 개의 조건을 결합할 때는 Python의 기본 논리 연산자(and, or, not) 대신 Pandas의 비트 논리 연산자(&, |, ~)를 사용하고, 각 조건을 괄호로 묶어야 합니다. (예: df[(df['B'] > 11) & (df['D'] < 20)])





print("========================================================================================================================================================================")





print("# df \n", type(df))
print(df)
# 원본 DataFrame을 다시 출력합니다.

s = pd.Series([False,True,False], index=['a','b','c'])
# 1. "불리언 Series 's' 생성": DataFrame 'df'의 행 개수와 동일한 3개의 불리언 값([False, True, False])으로 구성된 Series를 만듭니다.
# 2. "인덱스 일치 중요": 이 Series의 인덱스(['a', 'b', 'c'])는 "반드시" 원본 DataFrame 'df'의 행 인덱스와 "일치"해야 합니다.
# 3. 이 Series는 df의 행을 필터링하는 "마스크(Mask)" 역할을 합니다. (a행은 False, b행은 True, c행은 False)

print("\n s \n", type(s), '\n', s)
# 생성된 불리언 Series의 타입과 내용을 출력합니다.

temp = df[s]
# 1. "불리언 인덱싱 적용": 단일 대괄호(`[]`) 안에 불리언 Series 's'를 전달합니다.
# 2. Pandas는 's'의 값이 "True"인 "행('b' 행)"만 원본 DataFrame 'df'에서 추출합니다.
# 3. 결과는 추출된 행으로 구성된 "DataFrame" 객체로 반환됩니다.

print("\n df[s] \n", type(temp), '\n', temp)
# 결과의 타입(<class 'pandas.core.frame.DataFrame'>)과 내용을 출력합니다.



# 💡 핵심 포인트: 불리언 인덱싱
# 마스크 역할: 불리언 Series는 DataFrame의 각 행에 적용되는 필터 마스크 역할을 합니다.

# 길이 및 인덱스 일치: 불리언 Series의 길이는 DataFrame의 행 개수와 같아야 하며, 인덱스는 필터링하려는 DataFrame의 행 인덱스와 일치해야 합니다.

# 활용: 불리언 인덱싱은 보통 df[df['Column'] > value]와 같이, 데이터프레임 내의 조건을 통해 불리언 Series를 생성한 후 필터링하는 방식으로 활용됩니다.




print("========================================================================================================================================================================")





print("# df \n", type(df))
print(df)

temp = df.loc[df.A > 15]
# 1. "df.A > 15": 먼저 조건을 생성합니다. 'A' 열의 값이 15보다 큰지 확인하여 "불리언 Series"를 만듭니다. (결과: a(False), b(False), c(True))
# 2. `df.loc[...]`: 이 불리언 Series를 `df.loc`의 행 선택 위치에 전달합니다.
# 3. 불리언 Series에서 "True"인 인덱스에 해당하는 "원래 DataFrame의 행 전체"가 선택됩니다.
# 4. 결과: 'A' 값이 15를 초과하는 행('c')만 포함하는 "DataFrame"이 반환됩니다.

print("\n df.loc[df.A > 15] \n", type(temp), '\n', temp)

s = df.A > 15
# 1. "df.A > 15": 조건을 별도의 변수 `s`에 저장하여 재사용합니다.
# 2. `s`는 인덱스와 불리언 값(True/False)을 가진 "Series" 객체입니다. (인덱스는 df의 행 인덱스와 동일)
# 3. 결과: Series (a False, b False, c True)

print("\n step1. s = df.A > 15 \n", type(s), '\n', s)

temp = df.loc[s]
# 1. `df.loc[s]`: 위에서 만든 불리언 Series `s`를 `df.loc`에 전달하여 필터링합니다.
# 2. 이는 `df.loc[df.A > 15]`와 "완전히 동일한 결과"를 얻습니다.
# 3. 이 두 단계 분리 방식은 복잡한 다중 조건 필터링 시 코드를 "더 읽기 쉽게" 만듭니다.

print("\n step2. df.loc[s] \n", type(temp), '\n', temp)




# 💡 핵심 원리: 불리언 인덱싱 (Boolean Indexing)
# 조건 생성: df.A > 15와 같은 조건문은 DataFrame의 인덱스와 True/False 값으로 구성된 불리언 Series를 만듭니다.

# 필터링: 이 불리언 Series를 df.loc[] 안에 전달하면, Pandas는 True 값에 해당하는 행만 선택하고 False 값에 해당하는 행은 버립니다.

# .loc 사용: 불리언 인덱싱은 암묵적 슬라이싱(df[...])에서도 작동하지만, 복잡한 조건이나 행/열 선택을 결합할 때는 ".loc"를 사용하는 것이 "가장 명확하고 표준적인 방법"입니다.





print("========================================================================================================================================================================")





print("# df \n", type(df))
print(df)
# 원본 DataFrame 출력

s = pd.Series([True, True, False], index=['a', 'b', 'c'])
# 1. 불리언 Series 's' 생성: DataFrame 'df'와 "동일한 행 레이블" ('a', 'b', 'c')을 가집니다.
# 2. 'a'와 'b' 행에 대해 True, 'c' 행에 대해 False 값을 설정했습니다.
# 3. [참고] 불리언 Series를 생성할 때, 인덱스가 원본 DataFrame과 "정확히 일치"하고 "길이가 동일"해야 합니다.

print("\n s \n", type(s), '\n', s)
# 생성된 불리언 Series 's'의 타입과 내용을 출력합니다.

temp = df.loc[s] # .loc에 불리언 Series 전달
# 1. "명시적 레이블 접근자" `.loc`에 불리언 Series `s`를 **단독으로** 전달했습니다.
# 2. `.loc[s]`는 불리언 Series `s`의 값이 **True인 행** (레이블 'a', 'b')만을 **필터링**하여 추출합니다.
# 3. 결과는 **행 'a'와 'b'**만을 포함하는 "DataFrame" 객체로 반환됩니다. (열은 모두 유지됩니다.)


print("\n df.loc[s] \n", type(temp), '\n', temp)
# 필터링된 결과의 타입(<class 'pandas.core.frame.DataFrame'>)과 내용을 출력합니다.




# 🔑 불리언 인덱싱의 핵심 원리
# 필터링: 불리언 Series를 DataFrame의 선택자로 사용하면, True에 해당하는 위치의 행만 결과 DataFrame에 포함됩니다.

# .loc 사용: 불리언 Series를 단독으로 사용하는 경우, 일반적으로 df[s] 또는 df.loc[s] 모두 동일하게 작동하지만, .loc를 사용하는 것이 가독성과 명확성 측면에서 더 권장됩니다.

# 길이 및 인덱스 일치: 불리언 Series의 길이와 인덱스는 필터링 대상 DataFrame의 행 길이와 인덱스와 정확히 일치해야 합니다.




print("========================================================================================================================================================================")






















# # --- DataFrame 생성 ---
# # np.arange(10, 22): 10부터 시작하여 (22-1)인 21까지의 정수(총 12개)를 갖는 1차원 배열을 생성합니다.
# # .reshape(3, 4): 위 1차원 배열을 3행 4열의 2차원 배열로 변형합니다.
# # pd.DataFrame(...): 이 2차원 배열을 데이터로 사용하여 DataFrame을 생성하고 변수 df에 저장합니다.
# df = pd.DataFrame(
#     np.arange(10, 22).reshape(3,4), 
#     index=["a", "b", "c"],   # index 매개변수를 사용하여 행(Row)의 레이블(이름)을 ['a', 'b', 'c']로 지정합니다.
#     columns=["A", "B", "C", "D"] # columns 매개변수를 사용하여 열(Column)의 레이블(이름)을 ['A', 'B', 'C', 'D']로 지정합니다.
# )


# # --- 데이터 선택 (loc 인덱서) ---
# # .loc는 레이블(이름) 기반으로 데이터에 접근합니다.
# # 기본 형식은 df.loc[행 레이블, 열 레이블]이며, 
# # 행 레이블만 주어지면 해당 행 전체를 선택합니다.

# print(df.loc['a'])  # 행 레이블이 "'a'"인 "행 전체"를 선택합니다.
#                     # 결과는 'A', 'B', 'C', 'D'를 인덱스로 갖는 pandas Series 객체가 됩니다.

# print(df.loc['A'])  # 행 레이블이 "'A'"인 행을 선택하려고 시도합니다.
#                     # 이 DataFrame에는 'A'라는 이름의 "행 인덱스"가 없기 때문에
#                     # 실행 시 "KeyError"가 발생합니다. 
#                     # (df.loc는 열 이름을 통한 선택이 아닌, 행 이름(레이블)을 통한 선택을 우선시합니다.)



# # --- 행 슬라이싱 (Row Slicing) ---
# # 1. .loc를 사용한 슬라이싱 (레이블 기반)
# print(df.loc['b':'c']) # ".loc" 접근자를 사용하며, 'b'부터 'c'까지의 "행 레이블 범위"를 슬라이싱합니다.
#                        # "레이블 기반 슬라이싱"의 특징: 끝 인덱스인 'c'도 "포함"하여 선택합니다.
#                        # 결과: 행 'b'와 행 'c'가 모두 출력됩니다.

# # 2. 일반 대괄호 []를 사용한 슬라이싱 (레이블 기반)
# print(df['b':'c'])     # DataFrame에서 일반 대괄호 `[]` 안에 슬라이싱 구문(시작:끝)을 사용하면
#                        # 이는 "행 레이블 기반 슬라이싱"으로 동작합니다.
#                        # 이 역시 "레이블 기반"이므로 끝 레이블인 'c'를 "포함"하여 선택합니다.
#                        # 결과: 행 'b'와 행 'c'가 모두 출력됩니다.



# # --- 행 선택 (레이블 기반) ---
# # .loc: pandas에서 "레이블(이름)"을 기반으로 행과 열을 선택하는 데 사용되는 인덱서입니다.
# # ['b', 'c']: .loc의 첫 번째 인자(행 선택 위치)에 행 레이블 'b'와 'c'를 리스트 형태로 전달합니다.
# print(df.loc[['b','c']]) # DataFrame 'df'에서 행 레이블이 "'b'와 'c'"인 행들만을 선택하여 출력합니다.
#                          # 두 행과 모든 열을 포함하는 새로운 DataFrame이 반환됩니다.



# # --- 데이터 접근 및 오류 발생 ---
# # .loc 인덱서: 행(Row)과 열(Column)을 "레이블(이름)"을 기반으로 선택할 때 사용합니다.
# # df.loc[행 레이블, 열 레이블]
# print(df.loc['b','c']) # 'b'는 유효한 행 레이블이지만,
#                        # "'c'는 유효한 열 레이블이 아닙니다." (열 레이블은 'A', 'B', 'C', 'D'입니다.)
#                        # pandas는 'c'를 열 이름으로 찾으려고 시도하지만,
#                        # DataFrame에 'c'라는 이름의 열이 없기 때문에 "KeyError"가 발생합니다.



# # --- 행 선택 (단일 Series 반환) ---
# print(df.loc["b"]) # ".loc" 인덱서를 사용하여 행 레이블 'b'에 해당하는 "단일 행"을 선택합니다.
#                    # 선택된 결과는 "pandas Series" 객체로 반환됩니다.
#                    # Series의 인덱스는 원본 DataFrame의 열 이름('A', 'B', 'C', 'D')이 됩니다.



# # --- 행 선택 (DataFrame 반환) ---
# print(df.loc[["b"]]) # ".loc" 인덱서에 행 레이블 'b'를 "리스트 형태"(["b"])로 전달하여 선택합니다.
#                      # 하나의 레이블이라도 리스트로 감싸서 전달하면, 결과는 항상 "pandas DataFrame" 객체로 반환됩니다.
#                      # 이는 이후의 DataFrame 연산을 위해 일관된 구조를 유지할 때 유용합니다.



# # --- 데이터 선택 및 오류 발생 ---
# print(df[["b","c"]]) # DataFrame에서 대괄호 `[]` 안에 리스트를 넣어 여러 개의 "열(Column)"을 선택하려고 시도합니다.
#                      # pandas는 이 리스트의 요소들('b', 'c')을 "열 이름(Column Label)"로 간주하고 찾습니다.
#                      # 하지만 df의 열 이름은 'A', 'B', 'C', 'D'이고, 'b'와 'c'라는 열은 존재하지 않습니다.
#                      # 따라서 존재하지 않는 열 이름을 사용하여 접근했기 때문에 "KeyError"가 발생합니다.



# # --- 행 선택 ---
# print(df.loc[['b','c']]) # `.loc` 인덱서를 사용하여 데이터를 선택합니다.
#                          # `.loc`는 "레이블(이름)"을 기반으로 선택하며, 항상 "행(Row)"을 먼저 선택합니다.
#                          # [['b','c']]는 행 레이블 'b'와 'c'를 선택하는 리스트입니다.
#                          # 결과적으로 'b' 행과 'c' 행만 포함하는 새로운 DataFrame이 출력됩니다.



# # --- 열 선택 및 출력 ---
# print(df[["B","C"]]) # DataFrame df에서 대괄호 `[]` 안에 "열 이름"의 "리스트"를 전달하여 
#                      # 'B' 열과 'C' 열을 동시에 선택하고 출력합니다.
#                      # 결과는 선택된 열들로 구성된 새로운 DataFrame이 됩니다.



# # --- 열 선택 및 출력 ---
# print(df.A) # DataFrame `df`에서 "점(dot) 표기법"을 사용하여 열 이름 'A'에 해당하는 단일 열을 선택합니다.
#             # 이 방법은 열 이름이 유효한 Python 변수 이름 규칙을 따를 때 간편하게 사용할 수 있습니다.
#             # 선택된 열(Column 'A')은 "pandas Series 객체" 형태로 반환되어 출력됩니다.



# # --- 조건부 필터링 (불리언 인덱싱) ---
# # df.A: DataFrame df에서 'A'라는 이름의 열(Column)을 Series 형태로 선택합니다.
# # > 15: 선택된 Series의 모든 값에 대해 "'15보다 큰가?'"라는 조건(비교 연산)을 적용합니다.
# # 이 연산의 결과는 각 요소가 조건을 충족하는지 여부를 나타내는 "True/False 값"을 가진 새로운 "Series (불리언 Series)"가 됩니다.
# print(df.A > 15) # 조건 연산의 결과인 불리언 Series를 출력합니다.



# # --- 불리언 인덱싱을 이용한 행 선택 ---
# # df.A > 15 : 먼저 조건식을 계산합니다.
# # 1. df.A는 'A' 열(Series)을 선택합니다. (결과: [10, 14, 18])
# # 2. 각 값과 15를 비교하여 "불리언(True/False)" 값으로 이루어진 Series를 만듭니다.
# #    (결과: [False (10>15), False (14>15), True (18>15)])
# # 3. 이 불리언 Series를 df.loc[...]에 인수로 전달합니다.
# print(df.loc[df.A > 15]) # df.loc[] 접근자를 사용하여, 조건식(df.A > 15)의 결과가 "True인 행"만 선택하여 출력합니다.
#                          # 'A' 열의 값이 15보다 큰 행(여기서는 행 인덱스 'c')만 선택됩니다.



# # --- 행 선택 함수 정의 ---
# def sel_row(df) : # sel_row라는 이름의 함수를 정의하며, 입력으로 DataFrame(df)을 받습니다.
#     # df.A: DataFrame df에서 'A'라는 이름의 열(Series 객체)을 선택합니다.
#     # >15: 선택된 'A' 열의 각 요소가 15보다 큰지 비교 연산을 수행합니다.
#     # 이 연산의 결과로, 각 행마다 True 또는 False 값을 가지는 "불리언 Series"가 생성됩니다.
#     return df.A > 15 

# # --- 함수 실행 및 출력 ---
# sel_row(df) # 정의된 sel_row 함수에 생성된 DataFrame df를 인수로 넣어 실행하고, 그 결과를 출력합니다.



# # --- 단일 값 선택 ---
# # df.loc[행_레이블, 열_레이블]을 사용하여 특정 레이블을 가진 행과 열이 만나는 단일 스칼라 값(하나의 값)을 선택합니다.
# print(df.loc['a','A']) # 행 레이블 'a'와 열 레이블 'A'가 만나는 셀의 값을 출력합니다.
#                        # 이는 DataFrame의 가장 왼쪽 상단 값인 10을 의미합니다.



# # --- 값 수정 ---
# df.loc['a','A'] = 50 # `.loc` 인덱서를 사용하여 특정 위치의 데이터를 선택하고 새 값(50)을 할당하여 "수정"합니다.
#                      # .loc[행 레이블, 열 레이블] 형식으로 사용됩니다.
#                      # 'a' 행(Row)과 'A' 열(Column)이 교차하는 지점의 값을 50으로 변경합니다.
                     
# # print(df) # 변경된 DataFrame을 출력해보면, 원본 값 10이 50으로 바뀐 것을 확인할 수 있습니다.



# # --- 여러 방식의 데이터 선택 및 출력 ---
# # 1. 이중 대괄호(체이닝) 사용 (비추천 방식)
# print(df.loc[['a','b']]['A']) 
# # df.loc[['a','b']] : 행 인덱스 'a', 'b'에 해당하는 행 전체를 선택하여 "새로운 DataFrame"을 반환합니다.
# # ['A'] : 그 반환된 DataFrame에서 "열 이름 'A'"를 선택합니다.
# # 결과 타입: "Series" (단일 열 선택 시)


# # 2. .loc[행 인덱스, 열 인덱스] 정석 방식
# print(df.loc[['a','b'],'A'])
# # df.loc : 행 레이블과 열 레이블을 사용하여 선택하는 인덱서입니다.
# # [['a','b']] : 선택할 "행 레이블 리스트"입니다.
# # 'A' : 선택할 "단일 열 레이블"입니다.
# # 결과 타입: "Series" (단일 열 선택 시)


# # 3. .loc[행 인덱스, 열 인덱스 리스트] 정석 방식
# print(df.loc[['a','b'],['A']])
# # [['a','b']] : 선택할 행 레이블 리스트입니다.
# # ['A'] : 선택할 "열 레이블 리스트"입니다. (단일 열이더라도 리스트로 감싸면)
# # 결과 타입: "DataFrame" (열이 하나여도 리스트로 지정했으므로)





# # --- .loc를 사용한 행 선택의 여러가지 방법들 ---
# # 1. 단일 행 선택 (Series 반환)
# print(df.loc['a']) # .loc[행_레이블]: 행 인덱스 'a'에 해당하는 "단일 행"을 선택합니다.
#                    # 결과는 1차원 데이터인 "Series" 객체로 반환됩니다.

# # 2. 단일 행 선택 (DataFrame 반환)
# print(df.loc[['a']]) # .loc[[행_레이블_리스트]]: 행 레이블 'a'를 리스트 "['a']" 형태로 전달하여 선택합니다.
#                      # 결과는 "DataFrame" 객체로 반환됩니다 (2차원 구조 유지).

# # 3. 단일 행 선택 및 전체 열 슬라이스 (Series 반환)
# print(df.loc['a',:]) # .loc[행_레이블, 열_슬라이스]: 행 인덱스 'a'를 선택하고,
#                      # "':'"는 "모든 열(All Columns)"을 의미합니다.
#                      # 결과는 위 1번과 동일하게 "Series" 객체로 반환됩니다.

# # 4. 단일 행 선택 (리스트) 및 전체 열 슬라이스 (DataFrame 반환)
# print(df.loc[['a'],:]) # .loc[[행_레이블_리스트], 열_슬라이스]: 행 인덱스 'a'를 리스트 형태로 선택하고,
#                        # "':'"는 모든 열을 선택합니다.
#                        # 결과는 위 2번과 동일하게 "DataFrame" 객체로 반환됩니다.




# # --- DataFrame의 .loc 인덱서를 사용한 레이블 기반 선택 ---
# # 1. 단일 행 선택 (Series 반환)
# print(df.loc['a']) # 행 인덱스 'a'에 해당하는 "전체 행"을 선택합니다. 
#                    # 결과: Series (열 이름이 인덱스가 됨)

# # 2. 단일 행의 특정 열 범위 선택 (Series 반환)
# print(df.loc['a', 'B':'C']) # 행 인덱스 'a'를 선택하고, 그 행에서 열 인덱스 'B'부터 "'C'까지" (끝점 포함) 선택합니다.
#                             # 결과: Series

# # 3. 행 리스트 선택 (DataFrame 반환)
# print(df.loc[['a']]) # 행 인덱스 'a'를 "리스트"로 감싸서 선택합니다. 
#                      # 단일 행을 선택하더라도 리스트로 지정하면 "DataFrame" 형태로 반환됩니다.
#                      # 결과: DataFrame

# # 4. 행 리스트와 열 범위 선택 (DataFrame 반환)
# print(df.loc[['a'],"B":"C"]) # 행 인덱스 리스트 ['a']를 선택하고, 열 인덱스 'B'부터 'C'까지 선택합니다. 
#                              # 결과: DataFrame (1행 2열)

# # 5. 단일 행의 특정 열 리스트 선택 (Series 반환)
# print(df.loc['a', ['B','C']]) # 행 인덱스 'a'를 선택하고, 열 인덱스 "'B'와 'C'만" "리스트"로 지정하여 선택합니다.
#                               # 결과: Series





# # --- 데이터 선택 및 출력 ---
# print(df.loc['b':])         # 1. 행 선택: `.loc[행 슬라이스, ]`
#                             # 행 인덱스 'b'부터 끝까지(inclusive) 모든 행을 선택하고, 모든 열을 선택합니다.
#                             # 결과: DataFrame (2x4)

# print(df.loc['b':,'A'])     # 2. 행/열 동시 선택 (Series 반환): `.loc[행 슬라이스, 단일 열 이름]`
#                             # 행 인덱스 'b'부터 끝까지 선택하고, 열 'A'만 선택합니다.
#                             # 결과: Series (2개의 원소)

# print(df.loc['b':]['A'])    # 3. 인덱싱 조합 (Series 반환): `df.loc[행 슬라이스][단일 열 이름]`
#                             # 1차: `df.loc['b':]`로 'b'부터 끝까지의 행을 가진 DataFrame을 반환합니다.
#                             # 2차: 그 결과 DataFrame에 `['A']` 인덱싱을 적용하여 열 'A'를 선택합니다.
#                             # 결과: Series (2개의 원소). (2번과 결과는 같지만 연산 과정이 다릅니다.)

# print(df.loc['b':][['A']])  # 4. 인덱싱 조합 (DataFrame 반환): `df.loc[행 슬라이스][열 이름 리스트]`
#                             # 1차: `df.loc['b':]`로 'b'부터 끝까지의 행을 가진 DataFrame을 반환합니다.
#                             # 2차: 그 결과 DataFrame에 `[['A']]` 인덱싱을 적용하여 열 'A'를 "DataFrame" 형태로 선택합니다.
#                             # 결과: DataFrame (2x1)

# print(df.loc['b':,['A']])   # 5. 행/열 동시 선택 (DataFrame 반환): `.loc[행 슬라이스, 열 이름 리스트]`
#                             # 행 인덱스 'b'부터 끝까지 선택하고, 열 'A'를 "리스트" `['A']`로 지정하여 선택합니다.
#                             # 결과: DataFrame (2x1). (4번보다 빠르고 권장되는 방식입니다.)

# print(df.loc['b':,'A':'A']) # 6. 행/열 슬라이스 (DataFrame 반환): `.loc[행 슬라이스, 열 슬라이스]`
#                             # 행 인덱스 'b'부터 끝까지 선택하고, 열 'A'부터 'A'까지 슬라이싱(A열만 선택)합니다.
#                             # `.loc`에서는 슬라이싱 시 끝 인덱스도 포함(inclusive)되므로, 5번과 결과는 같습니다.
#                             # 결과: DataFrame (2x1)



# # --- 인덱싱 및 출력 ---
# # 1. 행 슬라이싱 (시작 레이블:끝 레이블)
# # .loc['a':'b']는 "행 레이블 'a'부터 'b'까지" (끝 레이블 'b' 포함) 모든 행을 선택합니다.
# # ".loc를 이용한 레이블 슬라이싱에서는 끝점도 포함"됩니다.
# print(df.loc['a':'b']) 

# # 2. 특정 행 리스트 선택
# # .loc[['a','b']]는 행 레이블 'a'와 'b'를 "리스트"로 지정하여 해당 행들만 선택합니다.
# print(df.loc[['a','b']])

# # 3. 행 선택 후 열 선택 (체인 인덱싱 - 권장하지 않음)
# # 1) 먼저 .loc[['a','b']]를 사용하여 'a'와 'b' 행을 선택합니다. (중간 DataFrame 생성)
# # 2) 그 결과 DataFrame에 다시 `[['B','D']]`를 적용하여 'B'와 'D' 열을 선택합니다.
# # *이러한 방식은 "Chain Indexing"으로, 가독성이 떨어지고 경우에 따라 'SettingWithCopyWarning'을 발생시키므로 "권장되지 않습니다."
# print(df.loc[['a','b']][['B','D']])

# # 4. 행과 열을 동시에 명시적 선택 (권장되는 방식)
# # .loc[행 선택, 열 선택] 구문을 사용하여 "행 리스트 ['a','b']"와 "열 리스트 ['B','D']"를 "쉼표(,)로 구분"하여 동시에 선택합니다.
# # 이는 데이터 선택 시 가장 명확하고 성능상 권장되는 방법입니다.
# print(df.loc[['a','b'],['B','D']])





# # --- iloc를 사용한 데이터 선택 (정수 위치 기반) ---
# print(df.iloc[0,1])      # [행 인덱스 0, 열 인덱스 1]을 선택합니다. (값: 11)

# print(df.iloc[0:2,1:2])  # [행 인덱스 0부터 1까지 (0, 1), 열 인덱스 1부터 1까지 (1)]을 선택합니다.
#                          # (결과: 2행 1열 DataFrame)
                         
# print(df.iloc[0:2])      # 행 인덱스 0부터 1까지 (0, 1)을 선택하고, 열 인덱스는 모두(전체) 선택합니다.
#                          # (결과: 2행 4열 DataFrame)
                         
# print(df.iloc[0:2,1])    # [행 인덱스 0부터 1까지 (0, 1), 열 인덱스 1]을 선택합니다.
#                          # (결과: 2개의 값을 가진 Series)
                         
# print(df.iloc[2])        # 행 인덱스 2 전체를 선택하고, 열은 모두 선택합니다. (값: 18, 19, 20, 21)
#                          # (결과: 1차원 Series)
                         
# print(df.iloc[2,1:2])    # [행 인덱스 2, 열 인덱스 1부터 1까지 (1)]을 선택합니다.
#                          # (결과: 1행 1열 DataFrame)
                         
# print(df.iloc[2:3,1:2])  # [행 인덱스 2부터 2까지 (2), 열 인덱스 1부터 1까지 (1)]을 선택합니다.
#                          # (결과: 1행 1열 DataFrame. 윗줄과의 차이는 슬라이싱을 사용하여 결과가 Series가 아닌 DataFrame임)
                         
# print(df.iloc[0:1,-2:])  # [행 인덱스 0부터 0까지 (0), 열 인덱스 끝에서 두 번째부터 끝까지 (2, 3)]을 선택합니다.
#                          # (결과: 1행 2열 DataFrame)
                         
# print(df.iloc[0,-2:])    # [행 인덱스 0, 열 인덱스 끝에서 두 번째부터 끝까지 (2, 3)]을 선택합니다.
#                          # (결과: 2개의 값을 가진 Series)
                         
# print(df.iloc[[0,1],[1,2]]) # [행 인덱스 0과 1, 열 인덱스 1과 2]를 선택합니다. (리스트를 사용한 비연속적 선택)
#                             # (결과: 2행 2열 DataFrame)










# # --- DataFrame 생성 ---
# # np.arange(10, 26): 10부터 시작하여 (26-1)인 25까지의 정수(총 16개)를 순서대로 갖는 1차원 배열을 생성합니다.
# #                    (결과: [10, 11, ..., 25])
# # .reshape(4, 4): 위 1차원 배열을 "4행 4열"의 2차원 배열로 변형합니다.
# # pd.DataFrame(...): 이 2차원 배열을 데이터로 사용하여 DataFrame을 생성합니다.
# df2 = pd.DataFrame(
#     np.arange(10, 26).reshape(4, 4), # DataFrame에 들어갈 4x4 데이터 배열
#     columns=['a','b','c','d']        # 생성될 DataFrame의 "열(Column) 이름"을 ['a', 'b', 'c', 'd']로 지정합니다.
# ) # 생성된 DataFrame을 변수 df2에 할당합니다.



# # --- 행 선택 방법 1: .loc[시작_레이블 : 끝_레이블] ---
# # .loc[] 접근자는 "레이블(이름)" 기반으로 행을 선택합니다.
# print(df2.loc[1:2])  # 행 인덱스 "1"부터 행 인덱스 "2"까지 "모두 포함"하여 선택합니다. (종료 레이블 포함)
#                      # 이 DataFrame의 행 인덱스가 정수(0, 1, 2, 3)이므로, 1과 2 레이블에 해당하는 행이 선택됩니다.
#                      # 결과: 행 1과 행 2
#                      # 이 연산은 원본 df2를 변경하지 않고, 선택된 행이 포함된 새로운 DataFrame을 반환합니다.



# # --- 행 선택 방법 2: 기본 인덱싱 [시작_위치 : 끝_위치] ---
# # DataFrame의 기본 대괄호 [] 안에 슬라이싱([start:stop])을 사용할 경우, "위치(position)" 기반으로 행을 선택합니다.
# # "주의": 기본 슬라이싱은 Python 리스트와 같이 "종료 위치는 포함하지 않습니다."
# print(df2[1:2])  # 1번 위치(두 번째 행)부터 2번 위치(세 번째 행) "직전"까지 선택합니다.
#                  # 즉, 위치 1에 해당하는 행만 선택됩니다.
#                  # 결과: 행 1만
#                  # 이 연산은 원본 df2를 변경하지 않고, 선택된 행이 포함된 새로운 DataFrame을 반환합니다.



# # --- 값 선택 및 출력 ---
# print(df2.loc[0,'a']) # DataFrame의 ".loc" 인덱서를 사용하여 값을 선택하고 출력합니다.
#                       # .loc[행 레이블, 열 레이블]의 형식으로 사용합니다.
#                       # 0: 선택할 "행 레이블" (기본 인덱스 0)
#                       # 'a': 선택할 "열 레이블" (열 이름 'a')
#                       # 결과적으로 "0행"과 "'a'열"이 교차하는 "단일 값"이 출력됩니다.












# # --- DataFrame 생성 ---
# # Dictionary 형태로 데이터를 준비합니다.
# # 'num_legs'와 'num_wings'가 열(Column) 이름이 됩니다.
# # index=['falcon', 'dog', 'cat', 'ant']로 행(Row) 이름(인덱스)을 지정합니다.
# df = pd.DataFrame({
#     'num_legs': [2, 4, 4, 6],    # 다리 수 데이터
#     'num_wings': [2, 0, 0, 0]    # 날개 수 데이터
# }, index=['falcon', 'dog', 'cat', 'ant']) # 행 인덱스: 'falcon', 'dog', 'cat', 'ant'
# # --- DataFrame 생성 끝 ---



# # --- 데이터 선택 및 출력 ---
# print(df.num_legs) # 1. "열 선택": DataFrame df에서 "점(`.`) 표기법"을 사용하여 'num_legs' 열을 선택합니다.
#                    # 선택된 결과는 Series 객체 형태로 출력됩니다.
#                    # 결과: 각 행 인덱스와 해당하는 다리 수([2, 4, 4, 6])가 출력됩니다.

# print(df.num_legs.value_counts()) # 2. "빈도수 계산 및 출력": 
#                                   # 먼저 df.num_legs로 'num_legs' Series를 선택합니다.
#                                   # 그 다음, .value_counts() 메서드를 호출합니다.
#                                   # 이 메서드는 Series 내의 "각 고유값(unique value)"이 "몇 번 등장했는지" (빈도수)를 계산하여 새로운 Series로 반환합니다.
#                                   # 결과: 다리 수(고유값)와 해당 빈도수가 내림차순으로 출력됩니다.


# # --- 값의 빈도 계산 및 출력 ---
# print(df.value_counts()) # DataFrame 전체에 대해 `.value_counts()` 메서드를 호출합니다.
#                          # 이 메서드는 기본적으로 DataFrame의 "모든 열"을 고려하여 
#                          # "고유한 행(Row) 조합" 각각이 데이터에 몇 번 나타나는지(빈도)를 계산합니다.
#                          # 결과는 빈도수를 값으로, 고유한 조합을 MultiIndex로 갖는 "Series" 형태로 반환됩니다.
#                          # (가장 빈도가 높은 조합부터 내림차순으로 정렬됩니다.)