import pandas as pd
import numpy as np
import random







# # --- 1. 첫 번째 DataFrame (고객 정보) 생성 ---
# df1 = pd.DataFrame({ # 고객번호와 이름 정보가 담긴 DataFrame df1을 생성합니다.
#     '고객번호' : [1001,1002,1003,1004,1005,1006,1007], # 7명의 고객 번호
#     '이름' : ['둘리','도우너','또치','길동','희동','마이콜','영희'] # 7명의 고객 이름
#     }, columns=['고객번호','이름']) 

# print(df1) # df1 출력
# # df1의 내용: 고객번호 1001~1007


# # --- 2. 두 번째 DataFrame (구매 내역) 생성 ---
# df2 = pd.DataFrame({ # 고객번호와 구매 금액 정보가 담긴 DataFrame df2를 생성합니다.
#     '고객번호':[1001,1001,1005,1006,1008,1001], # 고객번호 1008은 df1에 없는 새로운 고객입니다.
#     '금액' : [10000,20000,15000,5000,100000,30000] # 고객별 구매 금액
# }, columns=['고객번호','금액'])

# print(df2) # df2 출력
# # df2의 내용: 고객번호 1001이 여러 번 등장하고, 1008이 포함됨.


# # --- 3. 데이터 확인 ---
# print(df1.head(1)) # df1의 첫 행 출력
# print(df2.head(1)) # df2의 첫 행 출력
# # 두 df의 공통열(같은 이름을 갖는 컬럼) : 고객번호 # 주석: 병합의 기준 키가 될 공통 열을 확인합니다.


# # --- 4. DataFrame 병합 (Merge) ---
# # merge는 SQL의 JOIN과 유사하며, 두 테이블(DataFrame)을 공통 Key를 기준으로 합치는 작업입니다.
# # Key= 생략하면 공통열('고객번호')을 기준으로 "inner join"이 실행됩니다. (가장 일반적인 병합)

# # df1.merge(df2) # df1의 메서드로 df2를 인자로 받아 병합합니다. (객체 메서드 방식)
# print(df1.merge(df2))
# # pd.merge(df1,df2) # pandas 모듈 함수로 df1, df2를 인자로 받아 병합합니다. (모듈 함수 방식)
# print(pd.merge(df1,df2))

# # 📌 inner join (내부 조인) 결과 원칙:
# # 1. 병합 기준인 '고객번호'가 "두 DataFrame 모두에 존재하는 행"만 결과에 포함됩니다.
# #    - df1에만 있는 고객(1002, 1003, 1004, 1007)은 제외됩니다.
# #    - df2에만 있는 고객(1008)은 제외됩니다.
# # 2. df2에서 '고객번호' 1001은 3번 등장하므로, "1001 고객의 정보('둘리')는 3번 반복"되어 나타납니다.


# # --- 5. Outer Join (전체 병합) ---
# # "how='outer'": "두 DataFrame의 모든 '고객번호'"를 기준으로 병합합니다.
# # df1에만 있는 고객(1002, 1003, 1004, 1007)은 df2의 '금액' 열에 "NaN"이 채워집니다.
# # df2에만 있는 고객(1008)은 df1의 '이름' 열에 "NaN"이 채워집니다.
# print(pd.merge(df1,df2,how='outer')) 


# # --- 6. Left/Right Join (기준 테이블 병합) ---
# # how='left'는 "df1 (왼쪽 테이블)"의 모든 '고객번호'를 기준으로 병합합니다.
# # (df1의 모든 고객(1001~1007)은 포함되며, 짝이 없는 df2의 1008은 제외됩니다.)
# # (df2에 짝이 없는 df1의 행은 금액 열이 NaN으로 채워집니다.)
# print(pd.merge(df1,df2,how='left')) 

# # how='right'는 "df2 (오른쪽 테이블)"의 모든 '고객번호'를 기준으로 병합합니다.
# # (df2에 있는 모든 고객(1001, 1005, 1006, 1008)은 포함되며, 짝이 없는 df1의 고객은 제외됩니다.)
# # (df1에 짝이 없는 df2의 행(1008)은 이름 열이 NaN으로 채워집니다.)
# print(pd.merge(df1,df2,how='right')) 



# print(pd.merge(df1,df2,how='right'))
# # 결과: "오른쪽 DataFrame (df2)의 모든 행"을 유지하고, 왼쪽 df1의 일치하는 행을 결합합니다.
# #       - df2의 6개 구매 내역은 모두 보존됩니다.
# #       - df1에만 있는 고객(1002, 1003, 1004, 1007)은 제외됩니다.
# #       - df2에만 있는 고객 1008의 '이름'은 NaN(결측치)으로 채워집니다.

# print(df2.merge(df1, how='left')) # df2가 왼쪽이 되므로, how='left'를 사용하면 위와 동일한 결과가 나옵니다.
#                                   # 즉, df2의 모든 행이 보존됩니다.












# # --- 1. 첫 번째 DataFrame (df1: 품종별 꽃잎 길이 정보) 생성 ---
# df1 = pd.DataFrame({
#     '품종':['setosa','setosa','virginica','virginica'], # 품종 열: setosa 2개, virginica 2개
#     '꽃잎길이':[1.4,1.3,1.5,1.3]                     # 꽃잎길이 열
# }, columns=['품종','꽃잎길이'])
# print(df1) # df1 출력 (4행 2열)


# # --- 2. 두 번째 DataFrame (df2: 품종별 꽃잎 너비 정보) 생성 ---
# df2 = pd.DataFrame({
#     '품종': ['setosa','virginica','virginica','ersicolor'], # 품종 열: setosa 1개, virginica 2개, ersicolor 1개
#     '꽃잎너비':[0.4,0.3,0.5,0.3]                      # 꽃잎너비 열
# }, columns=['품종','꽃잎너비'])
# print(df2) # df2 출력 (4행 2열)


# # --- 3. 공통열 확인 ---
# print(df1.head(1)) # df1의 첫 번째 행 출력
# print(df2.head(1)) # df2의 첫 번째 행 출력
# # 두 DataFrame의 공통열(키)은 '품종'입니다. 이 열을 기준으로 병합이 수행됩니다.
# # (참고: df1의 '품종' 개수와 df2의 '품종' 개수가 다르고, 'ersicolor'는 한쪽에만 존재합니다.)


# print(pd.merge(df1,df2)) # pd.merge(df1, df2) 호출
# # 결과: pd.merge 함수는 기본적으로 "how='inner'" (내부 결합) 방식으로 동작하며,
# #       "공통 열('품종')의 값이 양쪽 DataFrame에 모두 존재하는 행만"을 기준으로 결합합니다.
# #       - '품종' 값이 'setosa', 'virginica'인 행들만 결합됩니다.
# #       - df2에만 존재하는 'ersicolor' 품종은 결과에서 제외됩니다.
# #       - "카테시안 곱 (Cartesian Product)": 두 DataFrame에서 일치하는 품종이 있을 경우,
# #         각각의 모든 조합을 결합합니다.
# #         * 'setosa' (df1: 2개, df2: 1개) -> 2 * 1 = 2행 결합
# #         * 'virginica' (df1: 2개, df2: 2개) -> 2 * 2 = 4행 결합
# #       - 최종적으로 2 + 4 = 총 6개의 행이 결합됩니다.









# # --- 1. 첫 번째 DataFrame (df1: 구매 데이터) 생성 ---
# df1 = pd.DataFrame({ # 고객의 날짜별 구매 내역을 담는 DataFrame df1 생성
#     '고객명':['춘향','춘향','몽룡'], # '춘향' 데이터가 두 번 등장합니다.
#     '날짜' : ['2018-01-01','2018-01-02','2018-01-01'],
#     '데이터':[20000,30000,100000] # 이 '데이터' 열은 '금액' 정보를 담고 있습니다.
# })
# print(df1) # df1 출력 (3행 3열)


# # --- 2. 두 번째 DataFrame (df2: 고객 성별 데이터) 생성 ---
# df2 = pd.DataFrame({ # 고객의 성별 정보를 담는 DataFrame df2 생성
#     '고객명':['춘향','몽룡'],
#     '데이터':['여자','남자'] # 이 '데이터' 열은 '성별' 정보를 담고 있습니다.
# })
# print(df2) # df2 출력 (2행 2열)

# # --- 3. 공통열 확인 ---
# print(df1.head(1)) # df1의 첫 번째 행 출력
# print(df2.head(1)) # df2의 첫 번째 행 출력
# # 두 DataFrame의 공통 열 이름은 "'고객명'"과 "'데이터'" 두 개입니다.


# print(pd.merge(df1,df2, on='고객명'))
# # 결과: "how='inner'" (기본값) 방식으로 동작하며, "'고객명'" 열만을 기준으로 결합합니다.
# #       - '고객명'이 양쪽에 모두 존재하는 '춘향', '몽룡'만 결합됩니다.
# #       - df1의 '춘향' 데이터 2개와 df2의 '춘향' 데이터 1개가 결합되어 '춘향'에 대한 행이 2개 생성됩니다.
# #       - df1과 df2에 모두 존재하는 "'데이터' 열"은 이름이 겹치므로,
# #         df1의 '데이터'는 "데이터_x" (금액 정보)로, df2의 '데이터'는 "데이터_y" (성별 정보)로 자동으로 이름이 변경됩니다.


# print(df1.merge(df2, on='고객명',how='outer'))
# # 결과: "how='outer'" 방식으로 동작하여 "'고객명'" 기준으로 양쪽 DataFrame의 "모든 행"을 포함하여 결합합니다.
# #       - 이 예시에서는 df1과 df2의 '고객명'이 모두 일치하므로, Inner Join과 행 개수는 동일합니다.
# #       - 만약 한쪽에만 존재하는 고객이 있다면, 해당 고객의 행이 추가되며 일치하지 않는 열은 NaN으로 채워집니다.
# #       - 역시 겹치는 '데이터' 열은 "데이터_x"와 "데이터_y"로 분리됩니다.










# # --- 1. 첫 번째 DataFrame (df1: 이름, 성적) 생성 ---
# df1 = pd.DataFrame({ # 이름과 성적 정보를 담는 DataFrame df1 생성
#     '이름' :['영희','철수','철수'], # '철수'가 두 번 등장합니다.
#     '성적' :[90,80,80]            # '성적' 정보
# })
# # df1의 모습:
# #    이름  성적
# # 0  영희  90
# # 1  철수  80
# # 2  철수  80

# # --- 2. 두 번째 DataFrame (df2: 성명, 성적2) 생성 ---
# df2 = pd.DataFrame({ # 성명과 성적2 정보를 담는 DataFrame df2 생성
#     '성명' :['영희','영희','철수'], # '영희'가 두 번 등장합니다.
#     '성적2':[100,80,90]          # '성적2' 정보
# })
# # df2의 모습:
# #    성명  성적2
# # 0  영희  100
# # 1  영희   80
# # 2  철수   90

# df1.head(1) # df1의 첫 번째 행을 출력합니다.
# df2.head(1) # df2의 첫 번째 행을 출력합니다.
# # 확인: df1의 키는 '이름', df2의 키는 '성명'으로 이름이 다릅니다.



# print(pd.merge(df1,df2, # 병합할 두 DataFrame
#                left_on='이름',  # "왼쪽 DataFrame (df1)"에서 병합 기준으로 사용할 열 이름을 "'이름'"으로 지정합니다.
#                right_on='성명')) # "오른쪽 DataFrame (df2)"에서 병합 기준으로 사용할 열 이름을 "'성명'"으로 지정합니다.
# # 결과: how='inner'가 기본값으로 적용되어, '이름'과 '성명' 값이 일치하는 행들만 결합합니다.
# #       - '영희' (df1: 1개, df2: 2개) -> 1 * 2 = 2행 결합
# #       - '철수' (df1: 2개, df2: 1개) -> 2 * 1 = 2행 결합
# #       - 최종적으로 2 + 2 = 총 4개의 행이 결합 결과로 나오며,
# #       - 병합 기준이 된 '이름'과 '성명' 두 열은 결과 DataFrame에 "모두 보존됩니다".












# # --- 1. 첫 번째 DataFrame (df1: 일반 Column 기반) 생성 ---
# df1 = pd.DataFrame({ # 일반 열(Column)을 가진 DataFrame df1 생성 (도시 인구 데이터)
#     '도시': ['서울','서울','서울','부산','부산'],
#     '연도': [2000,2005,2010,2000,2005],
#     '인구':[9853972,9762546,9631482,3655437,3512547]
# })
# print(df1) # df1 출력 (5행 3열)

# # --- 2. 두 번째 DataFrame (df2: MultiIndex 기반) 생성 ---
# df2=pd.DataFrame(
#     np.arange(12).reshape((6,2)), # 0부터 11까지의 숫자를 6행 2열로 배열 생성
#     index=[['부산','부산','서울','서울','서울','서울'], # 첫 번째 레벨 인덱스: 도시 (MultiIndex 레벨 0)
#            [2000,2005,2000,2005,2010,2015]], # 두 번째 레벨 인덱스: 연도 (MultiIndex 레벨 1)
#     columns=['데이터1','데이터2'] # 열 이름
# )
# print(df2) # df2 출력 (6행 2열, MultiIndex)

# # --- 3. MultiIndex 기반 데이터 접근 확인 ---
# # df2.loc['부산']: 인덱스 레벨 0이 '부산'인 모든 행을 선택합니다.
# # .loc[2000]: 선택된 결과에서 다시 인덱스 레벨 1이 2000인 행을 선택합니다.
# print(df2.loc['부산'].loc[2000]) # df2에서 인덱스 ('부산', 2000)에 해당하는 행의 값(Series)을 출력합니다.

# # df2의 인덱스 확인
# print(df2.index) # df2의 MultiIndex 구조를 출력합니다.


# print(pd.merge(df1,df2,
#                left_on=['도시','연도'], # "왼쪽 df1"에서 병합 키로 사용할 "열(Column)"의 이름을 리스트로 지정합니다.
#                                          # (두 개의 일반 컬럼을 기준으로 사용)
#                right_index=True))     # "오른쪽 df2"에서 병합 키로 "행 인덱스 전체"를 사용하도록 지정합니다.
#                                          # (df2의 MultiIndex 레벨 0('도시')과 레벨 1('연도')을 순서대로 사용)
# # 결과: how='inner'가 기본값으로 적용되어, df1의 ['도시', '연도'] 쌍과 df2의 MultiIndex 쌍이 모두 일치하는 행만 결합됩니다.
# #       - df1의 ('서울', 2000), ('서울', 2005), ('서울', 2010), ('부산', 2000), ('부산', 2005)가 일치합니다.
# #       - df2에만 있는 ('서울', 2015)는 제외됩니다.
# #       - 최종적으로 5행 5열의 DataFrame이 생성됩니다.


# # pd.merge(df1,df2,...) 호출
# print(pd.merge(df1,df2,
#                left_index=True,  # "왼쪽 df1"에서 "행 인덱스(0, 1, 2, 3, 4)"를 병합 기준으로 사용합니다.
#                right_index=True, # "오른쪽 df2"에서 "행 인덱스(MultiIndex)"를 병합 기준으로 사용합니다.
#                how='outer'))     # "outer join" 방식으로 결합하여 양쪽의 모든 행을 보존합니다.
# # 결과: df1의 단순 정수 인덱스(0, 1, 2, 3, 4)와 df2의 MultiIndex는 서로 일치하는 값이 없으므로,
# #       모든 값이 NaN으로 채워진 거대한 Sparse DataFrame이 생성됩니다.
# #       "주의": 이 방식은 인덱스의 값과 구조가 완벽하게 동일할 때만 유효합니다.


# print(df1.join(df2, how='outer'))
# # 결과: DataFrame의 ".join() 메서드"를 사용하여 결합을 시도합니다.
# #       df1.join(df2)는 "df1의 인덱스"와 "df2의 인덱스"를 기준으로 결합을 시도합니다.
# #       (pd.merge(df1, df2, left_index=True, right_index=True)와 동일한 기본 동작)
# #       인덱스가 일치하지 않으므로, 마찬가지로 모든 값이 NaN으로 채워진 결과가 반환됩니다.
# #       "주의": join()은 주로 인덱스 기반 결합에 사용됩니다.










# # --- 1. 첫 번째 Series (s1) 생성 ---
# s1=pd.Series([0,1],      # 값을 [0, 1]로 설정합니다.
#              index=['A','B']) # 인덱스(레이블)를 ['A', 'B']로 설정합니다.
# print(s1) # s1 출력
# # 결과:
# # A    0
# # B    1

# # --- 2. 두 번째 Series (s2) 생성 ---
# s2=pd.Series([2,3,4],    # 값을 [2, 3, 4]로 설정합니다.
#              index=['A','B','C']) # 인덱스(레이블)를 ['A', 'B', 'C']로 설정합니다.
# print(s2) # s2 출력
# # 결과:
# # A    2
# # B    3
# # C    4

# print(pd.concat([s1,s2])) # pd.concat() 함수를 사용하여 s1과 s2 리스트를 순서대로 연결합니다.
# # 결과: "기본적으로 axis=0" (행 방향, 즉 수직 방향)으로 연결됩니다.
# #       s1의 모든 행(A, B) 뒤에 s2의 모든 행(A, B, C)이 그대로 이어 붙여집니다.
# #       - 인덱스 레이블은 보존되므로, 결과 Series에는 'A'와 'B' 레이블이 두 번씩 중복되어 나타납니다.
# #       - 'A'가 두 번, 'B'가 두 번, 'C'가 한 번 등장하는 총 5개의 요소로 이루어진 Series가 됩니다.



















# --- 첫 번째 DataFrame (df1) 생성 ---
df1 = pd.DataFrame({
    'A': ['A0', 'A1', 'A2', 'A3'],
    'B': ['B0', 'B1', 'B2', 'B3'],
    'C': ['C0', 'C1', 'C2', 'C3'],
    'D': ['D0', 'D1', 'D2', 'D3']},
    index=[0, 1, 2, 3]) # 열: A, B, C, D / 인덱스: 0, 1, 2, 3
print(df1)

# --- 두 번째 DataFrame (df2) 생성 ---
df2 = pd.DataFrame({
    'A': ['A4', 'A5', 'A6', 'A7'],
    'B': ['B4', 'B5', 'B6', 'B7'],
    'E': ['C4', 'C5', 'C6', 'C7'], # C와 D 대신 E와 F 열을 가짐
    'F': ['D4', 'D5', 'D6', 'D7']},
    index=[0, 1, 2, 3]) # 열: A, B, E, F / 인덱스: 0, 1, 2, 3
print(df2)

# --- 세 번째 DataFrame (df3) 생성 ---
df3 = pd.DataFrame({
    'A': ['A8', 'A9', 'A10', 'A11'],
    'B': ['B8', 'B9', 'B10', 'B11'],
    'C': ['C8', 'C9', 'C10', 'C11'],
    'O': ['D8', 'D9', 'D10', 'D11']}, # D 대신 O 열을 가짐
    index=[1,2,3,4]) # 열: A, B, C, O / 인덱스: 1, 2, 3, 4
print(df3)



# # 1. 기본 연결 (Outer Join, 인덱스 중복)
result = pd.concat([df1, df2, df3]) # 기본값: axis=0 (수직), join='outer' (전체 열 보존), ignore_index=False
print(result)
# 결과: 세 DataFrame의 모든 행이 순서대로 연결됩니다.
#       - 열: 모든 DataFrame에 존재하는 모든 열(A, B, C, D, E, F, O)이 보존됩니다.
#       - 열이 없는 부분은 NaN으로 채워집니다.
#       - 인덱스: 원본 인덱스(0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 4)가 그대로 유지되어 "인덱스가 중복"됩니다.


# # 2. MultiIndex 생성 (keys 사용)
result = pd.concat([df1, df2, df3], keys=['x','y','z']) # 연결된 각 DataFrame에 최상위 인덱스('x', 'y', 'z')를 부여합니다.
                                                        # 결과는 2 레벨의 MultiIndex를 갖게 됩니다. (최상위: x, y, z / 하위: 원본 인덱스)
print(result.loc['x'].loc[0,'A']) # MultiIndex에서 'x' 그룹을 선택하고, 그 안에서 인덱스 0의 'A' 열 값을 출력합니다. ('A0')


# # 3. Inner Join 연결 (join='inner')
result = pd.concat([df1, df2, df3], join='inner', keys=['x','y','z'])
print(result)
# 결과: 세 DataFrame에 "모두 존재하는 공통 열"만을 남기고 연결합니다.
#       - df1(A, B, C, D), df2(A, B, E, F), df3(A, B, C, O)의 공통 열은 "'A'와 'B'"뿐입니다.
#       - 'A'와 'B' 열만 남고, MultiIndex('x', 'y', 'z')는 유지됩니다.


# # 4. Inner Join 연결 (keys 없음)
result = pd.concat([df1, df2, df3], join='inner')
print(result)
# 결과: (3번과 동일하게) 공통 열('A', 'B')만 남고 연결됩니다.
#       - MultiIndex는 생성되지 않고, 원본의 중복 인덱스(0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 4)가 그대로 유지됩니다.


# # 5. 인덱스 무시 (ignore_index=True)
result = pd.concat([df1, df2, df3], join='inner', ignore_index=True)
print(result)
# 결과: (4번과 동일하게) 공통 열('A', 'B')만 남습니다.
#       - "ignore_index=True"로 인해 원본의 모든 인덱스 정보가 무시되고, 0부터 시작하는 새로운 정수 인덱스가 순차적으로 부여됩니다. (0부터 11까지)


# # 6. MultiIndex를 이용한 데이터 접근
result = pd.concat([df1, df2, df3], keys=['x','y','z']) # 2. MultiIndex 생성 결과와 동일한 DataFrame
print(result) # MultiIndex가 부여된 결과 DataFrame을 출력합니다.

print(result.loc['y'].loc[1]) # 최상위 인덱스 'y' (df2) 그룹 내에서, 하위 인덱스 1에 해당하는 행을 출력합니다.
                              # (결과: 'A1', 'B1', 'C5', 'D5', NaN, NaN)

print(result.loc['y'].loc[1:2]) # 'y' 그룹 내에서, 하위 인덱스 1부터 2까지의 행들을 "슬라이싱"하여 출력합니다.











# # --- 1. 첫 번째 DataFrame (df1) 생성 ---
# df1=pd.DataFrame(
#     np.arange(6).reshape(3,2), # 0부터 5까지의 숫자를 3행 2열로 만듭니다.
#     index=['a','b','c'], # 행 인덱스: a, b, c
#     columns=['데이터1','데이터2'] # 열 이름: 데이터1, 데이터2
# )
# print(df1) 

# # --- 2. 두 번째 DataFrame (df2) 생성 ---
# df2=pd.DataFrame(
#     5+np.arange(4).reshape(2,2), # 5부터 8까지의 숫자를 2행 2열로 만듭니다. (5, 6, 7, 8)
#     index=['a','c'],             # 행 인덱스: a, c (df1의 인덱스 'b'가 빠져있습니다.)
#     columns=['데이터2','데이터4'] # 열 이름: 데이터2, 데이터4 (df1의 '데이터1'이 빠져있습니다.)
# )
# print(df2)



# # ### 데이터 연결

# # # 1. 수평 연결 (axis=1, Outer Join)
# print(pd.concat([df1, df2],axis=1)) # "axis=1"을 사용하여 "수평 방향(열 기준)"으로 연결합니다.
# # join='outer'가 기본값이므로, "양쪽 DataFrame의 모든 인덱스"('a', 'b', 'c')를 보존합니다.
# # - df1에만 있는 인덱스 'b'의 df2 열은 NaN으로 채워집니다.
# # - df2에만 있는 열 '데이터4'의 df1 행은 NaN으로 채워집니다.
# # - 결과 열: 데이터1, 데이터2, 데이터2, 데이터4 (열 이름 중복 발생)

# # # 2. 수직 연결 (axis=0, Outer Join)
# print(pd.concat([df1, df2],axis=0)) # "axis=0"을 사용하여 "수직 방향(행 기준)"으로 연결합니다.
# # join='outer'가 기본값이므로, "양쪽 DataFrame의 모든 열"('데이터1', '데이터2', '데이터4')을 보존합니다.
# # - df1의 '데이터4'는 NaN으로, df2의 '데이터1'은 NaN으로 채워집니다.
# # - 인덱스: 원본 인덱스('a', 'b', 'c', 'a', 'c')가 그대로 유지되어 중복됩니다.


# # # 3. 수평 연결 (axis=1, Inner Join)
# print(pd.concat([df1,df2], axis=1, join='inner')) # 수평 방향으로 연결하되, "join='inner'"를 지정합니다.
# # 결과: "양쪽 DataFrame에 공통으로 존재하는 인덱스"('a', 'c')만을 남기고 연결합니다.
# # - df1에만 있는 인덱스 'b'는 제외됩니다.
# # - 결과 열: 데이터1, 데이터2, 데이터2, 데이터4 (모든 열은 보존됩니다. join 옵션은 axis의 반대 축에 영향을 줍니다.)

# test = pd.concat([df1,df2], axis=1, join='inner') # 결과를 'test'에 저장합니다.
# print(test.데이터2) # 'test' DataFrame에서 '데이터2' 열을 출력합니다.
# # 결과: '데이터2'라는 이름의 열이 두 개 있기 때문에, "두 열 모두" 포함된 DataFrame이 반환됩니다.


# # # 4. MultiIndex를 이용한 수평 연결 (axis=1, keys 사용)


# test = pd.concat([df1,df2], axis=1, join='inner',keys=['x','y']) # 수평 연결(inner join)을 수행하고,
#                                                                  # 연결된 두 DataFrame에 최상위 인덱스('x', 'y')를 부여합니다.
#                                                                  # 결과는 "MultiIndex(다중 인덱스)" Column을 갖게 됩니다.
# print(test)
# print(test.x) # MultiIndex Column에서 최상위 인덱스 'x' (df1) 그룹에 해당하는 모든 열을 출력합니다.
# print(test.x.데이터1) # 'x' 그룹 내의 '데이터1' 열을 선택하여 Series로 출력합니다.










df1=pd.DataFrame(
    np.arange(6).reshape(3,2), # 0부터 5까지의 숫자를 3행 2열로 만듭니다. (0, 1, 2, 3, 4, 5)
    index=['a','b','c'], # 행 인덱스: a, b, c
    columns=['데이터1','데이터2'] # 열 이름: 데이터1, 데이터2
)
print(df1) # df1 출력
# df1의 모양:
#   데이터1  데이터2
# a      0      1
# b      2      3
# c      4      5

# --- 2. 두 번째 DataFrame (df2) 생성 ---
df2 = pd.DataFrame([[5,4]], # 데이터를 [5, 4]를 포함하는 1행으로 생성합니다.
                   index=['d'], # 행 인덱스: d (df1의 인덱스와 겹치지 않습니다.)
                   columns=['데이터1','데이터2']) # 열 이름: 데이터1, 데이터2 (df1의 열 이름과 동일합니다.)
print(df2) # df2 출력
# df2의 모양:
#   데이터1  데이터2
# d      5      4


print(pd.concat([df1,df2])) # pd.concat() 함수를 사용하여 df1과 df2를 연결합니다.
# "axis=0" (수직 방향, 행 기준)이 기본값이므로, df1의 모든 행 뒤에 df2의 모든 행이 그대로 이어 붙여집니다.
# - 열 이름이 ('데이터1', '데이터2')로 동일하므로, 깔끔하게 연결됩니다.
# - 인덱스는 원본 인덱스('a', 'b', 'c', 'd')가 그대로 보존됩니다.



